<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>设计模式理论篇 | 面向对象设计原则 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">设计模式理论篇 | 面向对象设计原则</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">设计模式理论篇 | 面向对象设计原则</h1><div class="post-meta">Nov 30, 2019<span> | </span><span class="category"><a href="/categories/设计模式/">设计模式</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#综览"><span class="toc-text">综览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1）单一职责原则-Single-Responsibility-Principle-SRP"><span class="toc-text">1）单一职责原则(Single Responsibility Principle, SRP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）开闭原则-Open-Closed-Principle-OCP"><span class="toc-text">2）开闭原则(Open-Closed Principle, OCP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）里氏代换原则-Liskov-Substitution-Principle-LSP"><span class="toc-text">3）里氏代换原则(Liskov Substitution Principle, LSP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4）依赖倒转原则-Dependence-Inversion-Principle-DIP"><span class="toc-text">4）依赖倒转原则(Dependence  Inversion Principle, DIP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5）接口隔离原则-Interface-Segregation-Principle-ISP"><span class="toc-text">5）接口隔离原则(Interface Segregation Principle, ISP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6）合成复用原则-Composite-Reuse-Principle-CRP"><span class="toc-text">6）合成复用原则(Composite Reuse Principle, CRP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7）迪米特法则-Law-of-Demeter-LoD"><span class="toc-text">7）迪米特法则(Law of Demeter, LoD)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何<strong>同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一</strong>。</li>
<li>在面向对象设计中，<strong>可维护性的复用是以设计原则为基础</strong>的。<strong>每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平</strong>。</li>
<li>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。</li>
<li>面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，我们经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。</li>
</ul>
<h2 id="综览"><a href="#综览" class="headerlink" title="综览"></a>综览</h2><p>最常见的7种面向对象设计原则如下表所示（在使用频率一列中，数字越大表示使用越频繁）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">设计原则名称</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单一职责原则(Single Responsibility Principle, SRP)</td>
<td style="text-align:center">一个类只负责一个功能领域中的相应职责</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">开闭原则(Open-Closed Principle, OCP)</td>
<td style="text-align:center">软件实体应对扩展开放，而对修改关闭</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">里氏代换原则(Liskov Substitution Principle, LSP)</td>
<td style="text-align:center">所有引用基类对象的地方能够透明地使用其子类的对象</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">依赖倒转原则(Dependence  Inversion Principle, DIP)</td>
<td style="text-align:center">抽象不应该依赖于细节，细节应该依赖于抽象。即应该针对接口编程</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">接口隔离原则(Interface Segregation Principle, ISP)</td>
<td style="text-align:center">使用多个专门的接口，而不使用单一的总接口</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">合成复用原则(Composite Reuse Principle, CRP)</td>
<td style="text-align:center">尽量使用对象组合，而不是继承来达到复用的目的</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">迪米特法则(Law of Demeter, LoD)</td>
<td style="text-align:center">一个软件实体应当尽可能少地与其他实体发生相互作用</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<h2 id="1）单一职责原则-Single-Responsibility-Principle-SRP"><a href="#1）单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="1）单一职责原则(Single Responsibility Principle, SRP)"></a>1）单一职责原则(Single Responsibility Principle, SRP)</h2><ul>
<li>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</li>
<li>单一职责原则定义如下：<ul>
<li><strong>一个类只负责一个功能领域中的相应职责</strong></li>
<li>或者可以定义为：<strong>就一个类而言，应该只有一个引起它变化的原因。</strong></li>
</ul>
</li>
<li>单一职责原则告诉我们，一个类不能承担太多的职责。在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一个类中。</li>
<li><strong>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则</strong>，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</li>
</ul>
<h2 id="2）开闭原则-Open-Closed-Principle-OCP"><a href="#2）开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="2）开闭原则(Open-Closed Principle, OCP)"></a>2）开闭原则(Open-Closed Principle, OCP)</h2><ul>
<li>开闭原则是面向对象的可复用设计的第一块基石，它是<strong>最重要的面向对象设计原则</strong>。</li>
<li>开闭原则由Bertrand Meyer于1988年提出。</li>
<li>开闭原则定义如下：<ul>
<li><strong>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展</strong></li>
<li>在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</li>
</ul>
</li>
<li>为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键</strong>。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</li>
<li><strong>总结：开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等</strong></li>
</ul>
<h2 id="3）里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#3）里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="3）里氏代换原则(Liskov Substitution Principle, LSP)"></a>3）里氏代换原则(Liskov Substitution Principle, LSP)</h2><ul>
<li>里氏代换原则的通俗定义如下：<ul>
<li><strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong></li>
</ul>
</li>
<li>里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</strong>。</li>
<li>例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</li>
<li><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</li>
<li>在使用里氏代换原则时需要注意如下几个问题：<ol>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>
<li>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</li>
<li>Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</li>
</ol>
</li>
</ul>
<h2 id="4）依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#4）依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="4）依赖倒转原则(Dependence  Inversion Principle, DIP)"></a>4）依赖倒转原则(Dependence  Inversion Principle, DIP)</h2><ul>
<li>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</li>
<li>依赖倒置原则定义如下：<ul>
<li><strong>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程</strong>。</li>
</ul>
</li>
<li><strong>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情</strong>。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</li>
<li>在实现依赖倒转原则时，我们需要<strong>针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中</strong>。<strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象</strong>。常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过<strong>构造函数</strong>来传入具体类的对象，设值注入是指通过<strong>Setter方法</strong>来传入具体类的对象，而接口注入是指通过<strong>在接口中声明的业务方法</strong>来传入具体类的对象。这些<strong>方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象</strong>。</li>
<li><strong>总结：依赖倒置原则是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互</strong>。</li>
</ul>
<h2 id="5）接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#5）接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="5）接口隔离原则(Interface Segregation Principle, ISP)"></a>5）接口隔离原则(Interface Segregation Principle, ISP)</h2><ul>
<li>接口隔离原则定义如下：<ul>
<li><strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</strong>。</li>
</ul>
</li>
<li>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：<ol>
<li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做<strong>“角色隔离原则”</strong>。</li>
<li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</strong>。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为<strong>“定制服务”</strong>，即为不同的客户端提供宽窄不同的接口。</li>
</ol>
</li>
<li><strong>总结：接口隔离原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</strong></li>
</ul>
<h2 id="6）合成复用原则-Composite-Reuse-Principle-CRP"><a href="#6）合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="6）合成复用原则(Composite Reuse Principle, CRP)"></a>6）合成复用原则(Composite Reuse Principle, CRP)</h2><ul>
<li>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下：<ul>
<li><strong>尽量使用对象组合，而不是继承来达到复用的目的</strong></li>
</ul>
</li>
<li>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。<ul>
<li>简言之：<strong>复用时要尽量使用组合/聚合关系（关联关系），少用继承</strong>。</li>
</ul>
</li>
<li>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过<strong>组合/聚合关系</strong>或通过<strong>继承</strong>，但<strong>首先应该考虑使用组合/聚合</strong>，<strong>组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少</strong>；其次才考虑继承，<strong>在使用继承时，需要严格遵循里氏代换原则</strong>，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</li>
<li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</li>
<li>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</li>
<li>一般而言，如果两个类之间是<strong>“Has-A”的关系应使用组合或聚合</strong>，如果是<strong>“Is-A”关系可使用继承</strong>。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</li>
<li><strong>总结：多用组合，少用继承</strong></li>
</ul>
<h2 id="7）迪米特法则-Law-of-Demeter-LoD"><a href="#7）迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="7）迪米特法则(Law of Demeter, LoD)"></a>7）迪米特法则(Law of Demeter, LoD)</h2><ul>
<li>迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下：<ul>
<li><strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></li>
</ul>
</li>
<li>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系</strong>。</li>
<li>迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：<ol>
<li>当前对象本身(this)</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象；</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>
<li>当前对象所创建的对象。<br>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</li>
</ol>
</li>
<li>类之间只要有耦合关系，就叫朋友关系。<strong>耦合分为依赖、关联、聚合、组合等</strong>。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。迪米特法则要求陌生的类不要作为局部变量出现在类中。</li>
<li>在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</li>
<li>迪米特法则要求我们<strong>在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用</strong>。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。</li>
<li>在将迪米特法则运用到系统设计中时，要注意下面的几点：<ol>
<li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</li>
<li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限</li>
<li>在类的设计上，只要有可能，一个类型应当设计成不变类</li>
<li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</li>
</ol>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]<a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录（完整版）</a><br>[2]<a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">软件设计模式概述</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/11/30/设计模式理论篇-面向对象设计原则/" data-id="ck8ss1zlw001yc0ub3vdispxb" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACu0lEQVR42u3aQY7jMAwEwPz/07PAnnYR2G6SYiaH8inwKLZKASROS69XfP38vZI7/17vLd8/V9u/Ni48PDy8Vtevrvc2+RCcbXk/NJc9xMPDw1vj5Y9OXlBdNnrfigYODw8P71d5eflbneInZToeHh7e9/OqgKsnbAQTeHh4eJ/kJWFEXgRPium8zeGsBQ8PDy/mzePUz39e3N/Dw8PDG+yq5+Hs/dPuC+tqyV7oJx4eHt4C71S5nM/P81I7uVNOo/Hw8PCKvGq3kpbVaGMy9Y8CCDw8PLwWb/6IvFCeYPKBxsPDw9vjTeKD/HjB5IhA72d4yFrw8PDwjvLOhqrVsCMfgmhw8fDw8BZ41Wig9/pJ+JvfwcPDw/sMr7rRlefBSVfmB78eCn08PDy8Zd68sJ4Hu+UE+v6NeHh4eMu85EFJfNArmqsxcRRw4OHh4S3wTgWySSHeiySqRxBW8mY8PDy8eGqeTPTVZ05K88t+4uHh4S3wkrI1L3aTZSZfkCZh8cNviIeHh3eIly8DecGdBwq9AwfJG/Hw8PDO8nrHrSaBQi8+rgYor94Y4+Hh4bV4k4k+x/SijTwavlwY8PDw8Ma86r/31WCiOun3DngVQmc8PDy8Q7w8Qq0uA73DBNVtufLJCDw8PLwBr/qC+aZX0r4XVTyEEXh4eHiHeIU/j7em8oI4L6ALMQceHh7eId4nX9xbHnoxxH8pNR4eHt5R3mQLal4ozweo1x4PDw9vwvspXveBRVJYz8vl/D4eHh7eBi+/eoV1vq11KkTOjyng4eHhTXjVxaC63TUPgkcLAx4eHt4aL5/c84I479akOH7oGx4eHt4X8PLOJUVw3r56xAEPDw/vG3j3n3ulczUILsDw8PDwlnm9Y095MNFbNhLGw3fx8PDwFniTA1jJUpHHDb3yOu8nHh4e3pj3B103St/lh3JqAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/设计模式/">设计模式</a></div><div class="post-nav"><a class="pre" href="/2019/12/02/大数据理论篇-分布式SQL引擎Inceptor/">大数据理论篇 | 分布式SQL引擎Inceptor</a><a class="next" href="/2019/11/30/设计模式理论篇-设计模式综述/">设计模式理论篇 | 设计模式综述</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://dcrunnn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能与机器学习/">人工智能与机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试积累/">面试积累</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/人工智能与机器学习/" style="font-size: 15px;">人工智能与机器学习</a> <a href="/tags/分布式ETL工具/" style="font-size: 15px;">分布式ETL工具</a> <a href="/tags/分布式SQL引擎/" style="font-size: 15px;">分布式SQL引擎</a> <a href="/tags/分布式数据采集工具/" style="font-size: 15px;">分布式数据采集工具</a> <a href="/tags/分布式消息队列/" style="font-size: 15px;">分布式消息队列</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/面试积累/" style="font-size: 15px;">面试积累</a> <a href="/tags/分布式计算框架/" style="font-size: 15px;">分布式计算框架</a> <a href="/tags/分布式资源管理框架/" style="font-size: 15px;">分布式资源管理框架</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/春招积累-Java集合篇/">春招积累 | Java集合篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/01/春招积累-Java基础篇/">春招积累 | Java基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/JavaDaily/">JavaDaily</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/《Java8实战》-Chapter3-Lambda表达式/">《Java8实战》| Chapter3 Lambda表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/《Java8实战》-Chapter2 通过行为参数化传递代码/">《Java8实战》 | Chapter2 通过行为参数化传递代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/记一次右键菜单失效修复注册表的过程/">记一次右键菜单失效修复注册表的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/《Java8实战》-Chapter1 为什么要关心Java8/">《Java8实战》 | Chapter1 为什么要关心Java8</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/12/人工智能与机器学习概述/">人工智能与机器学习概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/06/设计模式理论篇-模板方法模式/">设计模式理论篇 | 模板方法模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/大数据理论篇-分布式SQL引擎Inceptor/">大数据理论篇 | 分布式SQL引擎Inceptor</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>