<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>用Java8来排排序 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">用Java8来排排序</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">用Java8来排排序</h1><div class="post-meta">Apr 22, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、定义简单实体类"><span class="toc-text">1、定义简单实体类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、不使用Lambda表达式的基本排序"><span class="toc-text">2、不使用Lambda表达式的基本排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、使用Lambda表达式的基本排序"><span class="toc-text">3、使用Lambda表达式的基本排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、没有类型定义（-Type-Definitions）的基本排序"><span class="toc-text">4、没有类型定义（ Type Definitions）的基本排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、使用静态方法的引用来排序"><span class="toc-text">5、使用静态方法的引用来排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、提取Comparator进行排序"><span class="toc-text">6、提取Comparator进行排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、反转排序"><span class="toc-text">7、反转排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、多条件排序"><span class="toc-text">8、多条件排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、多条件组合排序"><span class="toc-text">9、多条件组合排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、流操作"><span class="toc-text">1、流操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、实体类中hashCode和equals的处理"><span class="toc-text">2、实体类中hashCode和equals的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-More"><span class="toc-text">Read More</span></a></li></ol></div></div><div class="post-content"><h2 id="1、定义简单实体类"><a href="#1、定义简单实体类" class="headerlink" title="1、定义简单实体类"></a>1、定义简单实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、不使用Lambda表达式的基本排序"><a href="#2、不使用Lambda表达式的基本排序" class="headerlink" title="2、不使用Lambda表达式的基本排序"></a>2、不使用Lambda表达式的基本排序</h2><p>在Java 8之前，对集合进行排序要<strong>为Comparator创建一个匿名内部类</strong>用来排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;Human&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Human h1, Human h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h1.getName().compareTo(h2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单地用它来对Human实体列表进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human4"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    Collections.sort(humanList, <span class="keyword">new</span> Comparator&lt;Human&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Human h1, Human h2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> h1.getName().compareTo(h2.getName()); <span class="comment">// 根据name排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">打乱集合后，排序前：</span><br><span class="line">human1 -&gt; <span class="number">60</span></span><br><span class="line">human6 -&gt; <span class="number">10</span></span><br><span class="line">human2 -&gt; <span class="number">50</span></span><br><span class="line">human4 -&gt; <span class="number">30</span></span><br><span class="line">human5 -&gt; <span class="number">20</span></span><br><span class="line">human3 -&gt; <span class="number">40</span></span><br><span class="line">打乱集合后，排序后：</span><br><span class="line">human1 -&gt; <span class="number">60</span></span><br><span class="line">human2 -&gt; <span class="number">50</span></span><br><span class="line">human3 -&gt; <span class="number">40</span></span><br><span class="line">human4 -&gt; <span class="number">30</span></span><br><span class="line">human5 -&gt; <span class="number">20</span></span><br><span class="line">human6 -&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>将根据name排序改为根据age排序，在compare方法中改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> h1.getAge() - h2.getAge(); <span class="comment">// 根据age排序</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">打乱集合后，排序前：</span><br><span class="line">human3 -&gt; <span class="number">40</span></span><br><span class="line">human4 -&gt; <span class="number">30</span></span><br><span class="line">human2 -&gt; <span class="number">50</span></span><br><span class="line">human1 -&gt; <span class="number">60</span></span><br><span class="line">human6 -&gt; <span class="number">10</span></span><br><span class="line">human5 -&gt; <span class="number">20</span></span><br><span class="line">打乱集合后，排序后：</span><br><span class="line">human6 -&gt; <span class="number">10</span></span><br><span class="line">human5 -&gt; <span class="number">20</span></span><br><span class="line">human4 -&gt; <span class="number">30</span></span><br><span class="line">human3 -&gt; <span class="number">40</span></span><br><span class="line">human2 -&gt; <span class="number">50</span></span><br><span class="line">human1 -&gt; <span class="number">60</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3、使用Lambda表达式的基本排序"><a href="#3、使用Lambda表达式的基本排序" class="headerlink" title="3、使用Lambda表达式的基本排序"></a>3、使用Lambda表达式的基本排序</h2><p>根据Lambda表达式的介绍，我们现在可以不使用匿名内部类，只使用简单实用的语义就可以得到相同的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Human h1, Human h2) -&gt; h1.getName().compareTo(h2.getName());</span><br></pre></td></tr></table></figure></p>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human4"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change</span></span><br><span class="line">    humanList.sort((Human h1, Human h2) -&gt; h1.getName().compareTo(h2.getName()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：我们同样使用<strong>新的sort API，这个API在Java 8里被添加到java.util.List</strong> ——而不是旧的Collections.sort API。</p>
<h2 id="4、没有类型定义（-Type-Definitions）的基本排序"><a href="#4、没有类型定义（-Type-Definitions）的基本排序" class="headerlink" title="4、没有类型定义（ Type Definitions）的基本排序"></a>4、没有类型定义（ Type Definitions）的基本排序</h2><p>我们通过不指定类型定义来进一步简化表达式 ————<strong>编译器自己可以进行类型判断</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h1, h2) -&gt; h1.getName().compareTo(h2.getName())</span><br></pre></td></tr></table></figure></p>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human4"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change</span></span><br><span class="line">    humanList.sort((Human h1, Human h2) -&gt; h1.getName().compareTo(h2.getName()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5、使用静态方法的引用来排序"><a href="#5、使用静态方法的引用来排序" class="headerlink" title="5、使用静态方法的引用来排序"></a>5、使用静态方法的引用来排序</h2><p>下面我们将要使用带有静态方法引用的Lambda表达式去进行排序。<br>首先，我们要定义compareByNameThenAge方法 ——这个方法拥有与Comparator<human>对象里的compareTo方法完全相同的签名：</human></p>
<p>在Human类中加入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByNameThenAge</span><span class="params">(Human lhs, Human rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.name.equals(rhs.name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.age - rhs.age;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name.compareTo(rhs.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">humanList.sort(Human::compareByNameThenAge);</span><br></pre></td></tr></table></figure></p>
<p>最终结果是一个使用静态方法作为Comparator的有效的排序集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human4"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    humanList.sort(Human::compareByNameThenAge);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6、提取Comparator进行排序"><a href="#6、提取Comparator进行排序" class="headerlink" title="6、提取Comparator进行排序"></a>6、提取Comparator进行排序</h2><p>我们可以通过使用<strong>实例方法的引用</strong>和Comparator.comparing方法来避免定义比较逻辑——它会提取和创建一个基于那个函数的Comparable。<br>这个方法值得记住：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human4"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    humanList.sort(Comparator.comparing(Human::getName)); <span class="comment">//根据name排序</span></span><br><span class="line">    <span class="comment">// humanList.sort(Comparator.comparing(Human::getAge)); //根据age排序</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、反转排序"><a href="#7、反转排序" class="headerlink" title="7、反转排序"></a>7、反转排序</h2><p>JDK 8同样提供了一个有用的方法用来<strong>反转Comparator（reverse Comparator）</strong>——我们可以快速地利用它来反转我们的排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">humanList.sort(comparator.reversed());</span><br></pre></td></tr></table></figure></p>
<h2 id="8、多条件排序"><a href="#8、多条件排序" class="headerlink" title="8、多条件排序"></a>8、多条件排序</h2><p>比较操作的Lambda表达式不一定都是这么简单的——我们同样可以编写更复杂的表达式，比如先根据name后根据age来对实体进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">humanList.sort((lhs, rhs) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.getName().equals(rhs.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.getAge() - rhs.getAge();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.getName().compareTo(rhs.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="9、多条件组合排序"><a href="#9、多条件组合排序" class="headerlink" title="9、多条件组合排序"></a>9、多条件组合排序</h2><p>同样的比较逻辑——先根据name进行排序其次是age，同样可以通过Comparator新的组合支持来实现。</p>
<p><strong>从JDK 8开始，我们现在可以把多个Comparator链在一起（chain together）</strong>去建造更复杂的比较逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">humanList.sort(Comparator.comparing(Human::getName).thenComparing(Human::getAge));</span><br></pre></td></tr></table></figure></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="1、流操作"><a href="#1、流操作" class="headerlink" title="1、流操作"></a>1、流操作</h3><p>还可以引入jdk8中的流来操作集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">humanList.stream()</span><br><span class="line">    .sorted(Comparator.comparing(Human::getName).thenComparing(Human::getAge))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>
<p>但是要注意，流操作中不改变原来的集合，即上述代码没有改变humanList中元素的顺序，应该要用一个新的list来接收流的返回值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemoA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Human&gt; humanList = Lists.newArrayList();</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human1"</span>, <span class="number">60</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human2"</span>, <span class="number">50</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">40</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human3"</span>, <span class="number">30</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human5"</span>, <span class="number">20</span>));</span><br><span class="line">    humanList.add(<span class="keyword">new</span> Human(<span class="string">"human6"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱集合顺序</span></span><br><span class="line">    Collections.shuffle(humanList);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序前："</span>);</span><br><span class="line">    humanList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line"></span><br><span class="line">    List&lt;Human&gt; sortedList = humanList.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Human::getName).thenComparing(Human::getAge))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"打乱集合后，排序后："</span>);</span><br><span class="line">    sortedList.forEach(human -&gt; System.out.println(human.getName() + <span class="string">" -&gt; "</span> + human.getAge()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、实体类中hashCode和equals的处理"><a href="#2、实体类中hashCode和equals的处理" class="headerlink" title="2、实体类中hashCode和equals的处理"></a>2、实体类中hashCode和equals的处理</h3><p>(参考自阿里Java开发手册)<br>1） 只要重写 equals，就必须重写 hashCode。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。<br>3） 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals。<br>说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象 作为 key 来使用。</p>
<h2 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a>Read More</h2><p>[1]<a href="https://www.baeldung.com/java-8-sort-lambda" target="_blank" rel="noopener">英文原文：Basic Sort without Lambdas</a><br>[2]<a href="https://www.baeldung.com/java-tutorial" target="_blank" rel="noopener">Baeldung上的“Java ——回归基础”系列</a><br>[3]<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=200579174&amp;idx=2&amp;sn=c9f2cdd80a3d07954396d3195c7563c9&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">Java8学习资料</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/04/22/用Java8来排排序/" data-id="cjvdzzhi9001iy0ubezvac7dy" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLklEQVR42u3aS5KDMAxF0ex/02QDsblPKlKFfD1KpWnwYaBYn88Hr2uxyPX8GvJfrSVDhozXMq7tIg8gD17dYfUsvjcZMmScw9hvbk8in/l99ndYfi9DhgwZIPjy+9SCrwwZMmSkjP0RkBzsyOuQIUOGjDSJrQXitND2eC4uQ4aMFzJ41f3/nx/pb8iQIeNVjCtc6XGt38hEu5IhQ8ZoxtMNyH7gDvYjQ4aMAxj7MEoak7WEs9ZyuMnFZciQMYjBm4s8mKbg2uDFjxOuDBkyRjNIApke+zqhmb9QGTJknMAgobBfOEsbn+lfZciQMZuR3oIE5VpbNH1Z8fuTIUPGyxm1In4/+Hbaoj8CrgwZMo5hpN/UWpLplTfFOBkyZIxmpK3E/xTaSAhe7k2GDBnjGHzMiwTNWkO0NmwRZ8MyZMh4LYNH5X7RnzQeeEKLfj1kyJAxiNFpDJCt10psaTlPhgwZJzN425JstD+CttyDDBkyDmCkqWanbUmCcmuuTYYMGccw0lQzHZjgBTv0QmXIkHEAgzca+VGvE9CLAVeGDBmjGWlpvjNMxpsBQTFOhgwZQxlXuMgmyJhFOkB2Q5UhQ8ZoRmfOKpjgCAe80kaFDBkyTmDwkn2tVYkakOE18a+HDBkyRjB44KsdMWtpcxCyZciQIaM9IsaPmEWqDBkyZLTzY75FUoBbJrEyZMgYzeCjpelxkKSj6YCFDBkyTmOkqWOKrJXbHmlqypAh432ML0U7+ghRJpqXAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/Java8/">Java8</a><a href="/tags/Lambda/">Lambda</a></div><div class="post-nav"><a class="pre" href="/2019/05/02/《Java并发编程的艺术》笔记/">《Java并发编程的艺术》笔记</a><a class="next" href="/2019/04/21/为Maven配置阿里云镜像/">为Maven配置阿里云镜像</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://dcrunnn.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/学习Java线程池/">学习Java线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/02/《Java并发编程的艺术》笔记/">《Java并发编程的艺术》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/用Java8来排排序/">用Java8来排排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/为Maven配置阿里云镜像/">为Maven配置阿里云镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/阿里Java开发手册笔记/">阿里Java开发手册笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/SpringBoot使用ForkJoinPool进行并发编程/">SpringBoot使用ForkJoinPool编写多线程程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/设计模式之建造者模式-Builder-Pattern/">设计模式之建造者模式(Builder Pattern)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/代码简洁之道/">代码简洁之道</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/前端vue项目遇到的一些问题/">前端vue项目遇到的一些问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/springboot+vue整合security及jwt中遇到的坑/">springboot+vue整合security及jwt中遇到的坑</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>