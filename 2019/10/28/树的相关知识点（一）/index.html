<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>树的相关知识点（一） | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">树的相关知识点（一）</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">树的相关知识点（一）</h1><div class="post-meta">Oct 28, 2019<span> | </span><span class="category"><a href="/categories/数据结构与算法/">数据结构与算法</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、-综述"><span class="toc-text">一、 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、-相关名词"><span class="toc-text">二、 相关名词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、-二叉树的类型"><span class="toc-text">三、 二叉树的类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、-二叉树的性质"><span class="toc-text">四、 二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本性质"><span class="toc-text">基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#满二叉树的性质"><span class="toc-text">满二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完全二叉树的性质"><span class="toc-text">完全二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-平衡二叉树之AVL树"><span class="toc-text">5.3 平衡二叉树之AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a）定义"><span class="toc-text">a）定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b）性质"><span class="toc-text">b）性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c）效率"><span class="toc-text">c）效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d）AVL树的自平衡操作——旋转"><span class="toc-text">d）AVL树的自平衡操作——旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e）阅读资料"><span class="toc-text">e）阅读资料</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-平衡二叉树之红黑树"><span class="toc-text">5.4 平衡二叉树之红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a）定义-1"><span class="toc-text">a）定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b）性质-1"><span class="toc-text">b）性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c）效率-1"><span class="toc-text">c）效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d）红黑树的自平衡操作"><span class="toc-text">d）红黑树的自平衡操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e）阅读资料-1"><span class="toc-text">e）阅读资料</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他树"><span class="toc-text">其他树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B树"><span class="toc-text">B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-树"><span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-树-1"><span class="toc-text">B*树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie树"><span class="toc-text">Trie树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h1 id="一、-综述"><a href="#一、-综述" class="headerlink" title="一、 综述"></a>一、 综述</h1><p>树是一种在实际编程中经常遇到的数据结构，它是由n（n&gt;=1）个有限结点组成的一个具有层次关系的集合，把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。树具有以下特点：</p>
<ul>
<li>每个结点有零个或多个子结点</li>
<li>没有父结点的结点称为根结点</li>
<li>每一个非根结点有且只有一个父结点</li>
<li>除了根结点外，每个子结点可以分为多个不相交的子树</li>
</ul>
<p>示例图：<br><img src="/images/tree/示例图1.jpg" alt>  </p>
<h1 id="二、-相关名词"><a href="#二、-相关名词" class="headerlink" title="二、 相关名词"></a>二、 相关名词</h1><ul>
<li><p>节点：上图的圆圈，比如A、B、C等都是表示节点。节点一般代表一些实体，在java面向对象编程中，节点一般代表对象。</p>
</li>
<li><p>边：连接节点的线称为边，边表示节点的关联关系。一般从一个节点到另一个节点的唯一方法就是沿着一条顺着有边的道路前进。</p>
</li>
<li><p>路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。</p>
</li>
<li><p>根／根节点：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p>
</li>
<li><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点，B是D的父节点。</p>
</li>
<li><p>子节点：一个节点含有的子树的根节点称为该节点的子节点，D是B的子节点。</p>
</li>
<li><p>兄弟节点：具有相同父节点的节点互称为兄弟节点，比如上图的D和E就互称为兄弟节点。</p>
</li>
<li><p>堂兄弟节点：父节点在同一层的节点互为堂兄弟</p>
</li>
<li><p>叶节点／叶子节点：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。</p>
</li>
<li><p>子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p>
</li>
<li><p>节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推，D的层次为3。</p>
</li>
<li><p>深度：对于任意节点n，n的深度为从根到n的唯一路径长，根的深度为0，D的深度为2。</p>
</li>
<li><p>高度：对于任意节点n，n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0，D的高度为1。</p>
</li>
<li><p>节点的度：一个节点含有的子树的个数称为该节点的度</p>
</li>
<li><p>树的度：一棵树中，最大的节点的度称为树的度</p>
</li>
<li><p>节点的祖先：从根节点到该节点所经分支上的所有节点</p>
</li>
<li><p>子孙：以某节点为根的子树中任一节点都称为该节点的子孙</p>
</li>
<li><p>森林：由m(m&gt;=0)棵互不相交的树的集合称为森林</p>
</li>
<li><p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。</p>
</li>
<li><p>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。</p>
</li>
</ul>
<h1 id="三、-二叉树的类型"><a href="#三、-二叉树的类型" class="headerlink" title="三、 二叉树的类型"></a>三、 二叉树的类型</h1><ul>
<li><p><strong>二叉树</strong>：本身是有序树，且树的每个节点最多只能有两个子节点，即每个节点的度不超过2</p>
</li>
<li><p><strong>满二叉树</strong>：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p>
</li>
<li><p><strong>完全二叉树</strong>：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。特点：叶子结点只可能在最大的两层出现。或者说，如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
</li>
</ul>
<p><strong>注</strong>：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>
<ul>
<li><p><strong>平衡二叉树之AVL树</strong>：平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
</li>
<li><p><strong>平衡二叉树之红黑树</strong>：红黑树是一种自平衡的二叉查找树</p>
</li>
<li><p><strong>二叉查找树（BST）／二叉搜索树／二叉排序树</strong>：二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点。</li>
</ul>
</li>
<li><p><strong>带权二叉树：</strong></p>
<ul>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。</li>
<li>结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</li>
<li>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</li>
</ul>
</li>
<li><p><strong>哈夫曼树／霍夫曼树／最优二叉树：</strong></p>
<ul>
<li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。</li>
<li>哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</li>
</ul>
</li>
</ul>
<h1 id="四、-二叉树的性质"><a href="#四、-二叉树的性质" class="headerlink" title="四、 二叉树的性质"></a>四、 二叉树的性质</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ul>
<li>二叉树中，第 n 层最多有 2^(n-1) 个结点。</li>
<li>如果二叉树的深度为 K，那么此二叉树最多有 2^(k-1) 个结点。</li>
<li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1</li>
</ul>
<h2 id="满二叉树的性质"><a href="#满二叉树的性质" class="headerlink" title="满二叉树的性质"></a>满二叉树的性质</h2><ul>
<li>满二叉树的深度为h，最大层数为k，深度与最大层数相同，k=h;</li>
<li>满二叉树第i层的结点数是：2^(i-1)</li>
<li>深度为k的满二叉树，总结点数是：2^(k)-1，叶子数为 2^(k-1)，且总节点数一定是奇数。</li>
<li>二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有 n 个节点的满二叉树的深度为 log2(n+1)。</li>
</ul>
<h2 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h2><ul>
<li>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。<ul>
<li>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。 </li>
</ul>
</li>
<li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下几个结论成立：<ul>
<li>当 <figure class="highlight plain"><figcaption><span>时，父亲结点为结点 [i/2] 。（i</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   + 如果 ```2*i&gt;n```（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 ```2*i``` 。</span><br><span class="line">   + 如果 ```2*i+1&gt;n``` ，则结点 i 肯定没有右孩子；否则右孩子是结点 ```2*i+1``` 。</span><br><span class="line"></span><br><span class="line">![](/images/tree/tree2.jpg)  </span><br><span class="line"></span><br><span class="line"># 五、 几个重要的二叉树 #</span><br><span class="line"></span><br><span class="line">## 5.1 二叉查找树（BST） ##</span><br><span class="line"></span><br><span class="line">### 5.1.1 定义 ###</span><br><span class="line">二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： </span><br><span class="line">+ 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span><br><span class="line">+ 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</span><br><span class="line">+ 左、右子树也分别为二叉排序树；</span><br><span class="line">+ 没有键值相等的节点。</span><br><span class="line">　　</span><br><span class="line">### 5.1.2 性质 ###</span><br><span class="line">二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。</span><br><span class="line"></span><br><span class="line">### 5.1.3 复杂度 ###</span><br><span class="line">+ 二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</span><br><span class="line">+ 二叉查找树的高度决定了二叉查找树的查找效率。</span><br><span class="line"></span><br><span class="line">### 5.1.4 基本操作 ###</span><br><span class="line">二叉查找树的插入过程如下：</span><br><span class="line">1. 若当前的二叉查找树为空，则插入的元素为根节点;</span><br><span class="line">2. 若插入的元素值小于根节点值，则将元素插入到左子树中;</span><br><span class="line">3. 若插入的元素值不小于根节点值，则将元素插入到右子树中。</span><br><span class="line"></span><br><span class="line">二叉查找树的删除，分三种情况进行处理：</span><br><span class="line">+ p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;</span><br><span class="line">+ p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;</span><br><span class="line">+ p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。</span><br><span class="line">![](/images/tree/tree3.jpg)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.2 平衡二叉树 ##</span><br><span class="line">+ 我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。</span><br><span class="line">+ 我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</span><br><span class="line">+ 于是就有了我们下边介绍的平衡二叉树。</span><br><span class="line"></span><br><span class="line">平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。</span><br><span class="line"></span><br><span class="line">最小二叉平衡树的节点的公式如下：</span><br><span class="line">```java </span><br><span class="line">F(n)=F(n-1)+F(n-2)+1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p>
<h3 id="5-3-平衡二叉树之AVL树"><a href="#5-3-平衡二叉树之AVL树" class="headerlink" title="5.3 平衡二叉树之AVL树"></a>5.3 平衡二叉树之AVL树</h3><h4 id="a）定义"><a href="#a）定义" class="headerlink" title="a）定义"></a>a）定义</h4><p>AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度，其定义如下：</p>
<ol>
<li>本身首先是一棵二叉搜索树。</li>
<li>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</li>
</ol>
<h4 id="b）性质"><a href="#b）性质" class="headerlink" title="b）性质"></a>b）性质</h4><ul>
<li>左子树和右子树的高度之差的绝对值不超过1</li>
<li>树中的每个左子树和右子树都是AVL树</li>
<li>每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1,0,1。(每个节点的平衡因子等于右子树的高度减去左子树的高度 )   </li>
</ul>
<h4 id="c）效率"><a href="#c）效率" class="headerlink" title="c）效率"></a>c）效率</h4><ul>
<li>查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。</li>
<li>但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</li>
</ul>
<h4 id="d）AVL树的自平衡操作——旋转"><a href="#d）AVL树的自平衡操作——旋转" class="headerlink" title="d）AVL树的自平衡操作——旋转"></a>d）AVL树的自平衡操作——旋转</h4><ul>
<li>AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。</li>
<li>AVL树的基本操作是旋转，有四种旋转方式，分别为：左旋转，右旋转，左右旋转（先左后右），右左旋转（先右后左），实际上，这四种旋转操作两两对称，因而也可以说成两类旋转操作。</li>
</ul>
<h4 id="e）阅读资料"><a href="#e）阅读资料" class="headerlink" title="e）阅读资料"></a>e）阅读资料</h4><p>[1]<a href="http://dongxicheng.org/structure/avl/" target="_blank" rel="noopener">数据结构之AVL树</a><br>[2]<a href="https://blog.csdn.net/wanglelelihuanhuan/article/details/51863275" target="_blank" rel="noopener">AVL树详解</a><br>[3]<a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener">[Data Structure] 数据结构中各种树</a></p>
<h3 id="5-4-平衡二叉树之红黑树"><a href="#5-4-平衡二叉树之红黑树" class="headerlink" title="5.4 平衡二叉树之红黑树"></a>5.4 平衡二叉树之红黑树</h3><h4 id="a）定义-1"><a href="#a）定义-1" class="headerlink" title="a）定义"></a>a）定义</h4><ul>
<li>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。</li>
<li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。</li>
</ul>
<h4 id="b）性质-1"><a href="#b）性质-1" class="headerlink" title="b）性质"></a>b）性质</h4><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
<li>关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li>
</ol>
<p><img src="/images/tree/tree4.jpg" alt>  </p>
<h4 id="c）效率-1"><a href="#c）效率-1" class="headerlink" title="c）效率"></a>c）效率</h4><p>它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。</p>
<h4 id="d）红黑树的自平衡操作"><a href="#d）红黑树的自平衡操作" class="headerlink" title="d）红黑树的自平衡操作"></a>d）红黑树的自平衡操作</h4><ul>
<li>颜色变更 + 树旋转</li>
<li>因为每一个红黑树也是一个特殊的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。</li>
</ul>
<h4 id="e）阅读资料-1"><a href="#e）阅读资料-1" class="headerlink" title="e）阅读资料"></a>e）阅读资料</h4><p>[1]<a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener">[Data Structure] 数据结构中各种树</a><br>[2]<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap(HashMap引入红黑树优化)</a></p>
<h1 id="其他树"><a href="#其他树" class="headerlink" title="其他树"></a>其他树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树也是一种用于查找的平衡树，但是它不是二叉树。<br>B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的变体，也是一种多路搜索树</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a><code>B*</code>树</h2><p><code>B*</code>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><ul>
<li>Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。</li>
<li>典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</li>
<li>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener">[Data Structure] 数据结构中各种树</a><br>[2]<a href="http://data.biancheng.net/tree/" target="_blank" rel="noopener">数据结构树(Tree)详解</a><br>[3]<a href="https://songlee24.github.io/2015/01/13/binary-search-tree/" target="_blank" rel="noopener">BST</a><br>[4]<a href="https://blog.csdn.net/Recall_Tomorrow/article/details/70231324" target="_blank" rel="noopener">BST2</a><br>[5]<a href="https://www.cnblogs.com/zhazhaacmer/p/11052630.html" target="_blank" rel="noopener">手写二叉树-先序构造(泛型)-层序遍历（Java版）</a><br>[6]<a href="https://www.cnblogs.com/lzy321/p/10802660.html" target="_blank" rel="noopener">java：数据结构（四）二叉查找树以及树的三种遍历</a><br>[7]<a href="http://www.aiuxian.com/article/p-1364640.html" target="_blank" rel="noopener">数据结构 《22》—- 二叉树三种遍历的迭代器算法</a><br>[8]<a href="https://blog.csdn.net/u012975705/article/details/80258664" target="_blank" rel="noopener">树的四种遍历方法</a><br>[9]<a href="https://algorithm.yuanbin.me/zh-hans/binary_search_tree/binary_search_tree_iterator.html" target="_blank" rel="noopener">Binary Search Tree Iterator</a><br>[10]<a href="https://www.jianshu.com/p/456af5480cee" target="_blank" rel="noopener">二叉树遍历(先序、中序、后序)</a><br>[11]<a href="https://www.cnblogs.com/polly333/p/4740355.html#7" target="_blank" rel="noopener">浅谈数据结构-二叉树</a><br>[12]<a href="https://blog.csdn.net/jingangxin666/article/details/79941539" target="_blank" rel="noopener">数据结构 - 树的种类及其应用</a><br>[13]<a href="https://www.cnblogs.com/qjmnong/p/9135386.html" target="_blank" rel="noopener">二叉树的前序、中序、后序遍历迭代实现</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/10/28/树的相关知识点（一）/" data-id="ck3n32t2o0012d4ubh9htfcf7" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvElEQVR42u3awWrDMBAE0Pz/T7fQW0ltZrRSmsDzqaSJo+eAtMzu4xFfXz9X/srz3+37nz/7fIdtFx4eHt7S0q+ue0xy3QPu73b/OJJP4eHh4Z3j3R8G+a3vl752bCQP6PJ1PDw8vH/l7ToA5kU8Hh4e3qfwotvdFsprZXRS4uPh4eG9npds93nwmjPyg+R41oKHh4cX89oC9x3+Ptjfw8PDwxt01dttt92a14LdYp14eHh4B3hry8rL3zZKyD9bHBh4eHh4W3ltDLEWp7aDApOD4dfd8PDw8A7w2tGo/GCYN9jm41x4eHh4p3lrG/SkQE/K5TatrfMPPDw8vJKXB7VrbfukQF8ru6P14+Hh4R3gTc6TJFrd20JLHuVj13GJh4eHF2Sbu7bmZCn5e/L22x8rx8PDwzvAywPc9kGslbyTIPjydTw8PLytvLbuni83Hwto22CXvxseHh7eVl7ypuQwaMOIpOU/iYYvgwk8PDy8Ma+NA/J2VxvXtmMKUVyCh4eHd4CXxw15KJCX6ZPvKuIJPDw8vAO8vIxOQt58TqFe4uDQwsPDw9vFWyt8k/+2ofA8d72cjMDDw8M7wFsbBUgaXW3Jnt8tOqLw8PDwjvHmIwJtPJGHwpMiGw8PD+8cLw9w5/HurjZb9DPg4eHhHeDlH1j7mnlp3u7zl78hHh4e3lZevnEnt84fwaQ0rwtuPDw8vK28hNQ2vXJqstwNRwIeHh7eS3iToYEcvGv0Cg8PD+81vK/yagcF2sNm7QC4/C48PDy8A7wTowBrgeyk7N4AxsPDwyt5k8Mg+cq8Gda+czQfgYeHhzfmTTb6NsBNHlPbJMPDw8P7FF67WbdNr8mjxMPDw3sHXhsxtOFsG/JuHh3Aw8PDK3ntIiZDWvcLWmuALXb58PDw8KZrqxfdbvRr7MUAFw8PD28/7xtQ1ZKXRNiapwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/数据结构/">数据结构</a></div><div class="post-nav"><a class="pre" href="/2019/10/28/《程序员修炼之道》读书笔记/">《程序员修炼之道》读书笔记</a><a class="next" href="/2019/10/24/LeetCode-子数组题型总结/">LeetCode|子数组题型总结</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://dcrunnn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/分布式ETL工具/" style="font-size: 15px;">分布式ETL工具</a> <a href="/tags/分布式数据采集工具/" style="font-size: 15px;">分布式数据采集工具</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/分布式消息队列/" style="font-size: 15px;">分布式消息队列</a> <a href="/tags/分布式计算框架/" style="font-size: 15px;">分布式计算框架</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/分布式资源管理框架/" style="font-size: 15px;">分布式资源管理框架</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-面向对象设计原则/">设计模式理论篇 | 面向对象设计原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-设计模式综述/">设计模式理论篇 | 设计模式综述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-责任链模式/">设计模式理论篇 | 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-装饰者模式/">设计模式理论篇 | 装饰者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式消息队列Kafka/">大数据理论篇 | 分布式消息队列Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式数据采集工具Flume/">大数据理论篇 | 分布式数据采集工具Flume</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式ETL工具Sqoop/">大数据理论篇 | 分布式ETL工具Sqoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（Spark篇）/">大数据理论篇 | 分布式计算框架（Spark篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（MapReduce篇）/">大数据理论篇 | 分布式计算框架（MapReduce篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/27/设计模式理论篇-桥接模式/">设计模式理论篇 | 桥接模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>