<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>LeetCode|子数组题型总结 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeetCode|子数组题型总结</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeetCode|子数组题型总结</h1><div class="post-meta">Oct 24, 2019<span> | </span><span class="category"><a href="/categories/数据结构与算法/">数据结构与算法</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-53-最大子序和"><span class="toc-text">LeetCode 53 最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解法"><span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解法一：动态规划"><span class="toc-text">解法一：动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解法二：分治法"><span class="toc-text">解法二：分治法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子数组取值范围"><span class="toc-text">子数组取值范围</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解法：双端队列"><span class="toc-text">解法：双端队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-560-和为K的子数组"><span class="toc-text">LeetCode 560 和为K的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接-1"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解法-1"><span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解法一：前缀和（截取法）"><span class="toc-text">解法一：前缀和（截取法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解法二：Map查找"><span class="toc-text">解法二：Map查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-523-连续的子数组和"><span class="toc-text">LeetCode 523 连续的子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接-2"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-3"><span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解法二：Map查找-1"><span class="toc-text">解法二：Map查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-974-和可被-K-整除的子数组"><span class="toc-text">LeetCode 974 和可被 K 整除的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接-3"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-4"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解法-2"><span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解法一：前缀和（截取法）-1"><span class="toc-text">解法一：前缀和（截取法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解法二：Map查找法"><span class="toc-text">解法二：Map查找法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-713-乘积小于K的子数组"><span class="toc-text">LeetCode 713 乘积小于K的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接-4"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-5"><span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-795-区间子数组个数"><span class="toc-text">LeetCode 795 区间子数组个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目链接-5"><span class="toc-text">题目链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-6"><span class="toc-text">题目描述</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53 最大子序和"></a>LeetCode 53 最大子序和</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode链接</a> </p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><ul>
<li>遍历数组，设sum[i]为以数组第i个元素结尾的连续子数组的和的最大值，记最后结果为result</li>
<li>那么对于元素i，所有以它前面的元素结尾的子数组的最大和都已经求得，那么以第i个元素结尾且和最大的连续子数组，要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，即sum[i]= max(sum[i-1] + a[i], a[i])。</li>
<li>可以通过判断sum[i-1] + a[i]是否大于a[i]来做选择，而这实际上等价于判断sum[i-1]是否大于0</li>
<li>如果 sum[i-1] &gt; 0，则说明 sum[i-1] 对当前结果有增益效果，则 sum 保留并加上当前遍历数值</li>
<li>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</li>
<li>每次比较 sum[i] 和 result 的大小，将最大值置为result，遍历结束返回结果</li>
<li>由于每次运算只需要前一次的结果，因此并不需要像普通的动态规划那样保留之前所有的计算结果，只需要保留上一次的即可</li>
<li>时间复杂度：O(n)</li>
</ul>
<p>状态转移公式：<br>sum[i] = max(sum[i-1]+nums[i] , nums[i])<br>result = max(result,sum[i])</p>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayWithDP</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = Math.max(sum + nums[i], nums[i]); <span class="comment">//(1)</span></span><br><span class="line">        result = Math.max(result, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释中(1)处可以写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum = (sum + nums[i] &gt; nums[i]) ? sum + nums[i] : nums[i];</span><br><span class="line">或者</span><br><span class="line">sum = sum &gt; <span class="number">0</span> ? sum + nums[i] : nums[i];</span><br></pre></td></tr></table></figure></p>
<h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><p>将数组均分为两个部分，那么最大子数组会存在于</p>
<ul>
<li>左侧数组的最大子数组</li>
<li>右侧数组的最大子数组</li>
<li>左侧数组的以右侧边界为边界的最大子数组+右侧数组的以左侧边界为边界的最大子数组</li>
</ul>
<p>参考：<a href="https://www.jianshu.com/p/a0e17b0d3d87" target="_blank" rel="noopener">链接</a></p>
<h1 id="子数组取值范围"><a href="#子数组取值范围" class="headerlink" title="子数组取值范围"></a>子数组取值范围</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组arr和整数num，共返回有多少个子数组如下情况：</p>
<ul>
<li>max(arr[i..j]) - min(arr[i..j]) &lt;= num<ul>
<li>max(arr[i..j]) 表示子数组arr[i..j]中的最大值</li>
<li>min(arr[i..j]) 表示子数组arr[i..j]中的最小值</li>
</ul>
</li>
</ul>
<h2 id="解法：双端队列"><a href="#解法：双端队列" class="headerlink" title="解法：双端队列"></a>解法：双端队列</h2><ul>
<li>如果一个子数组从L-&gt;R中，max(arr[i..j]) - min(arr[i..j]) &lt;= num，那么在L-&gt;R范围内的子数组都符合要求<ul>
<li>我们以⼦数组 arr[i..j-1]为例说明, arr[i..j-1]最⼤值只可能⼩于或等于arr[i..j]的最大值, arr[i..j-1]最小值只可能大于或等于 arr[i..j]的最小值, 所以 arr[i..j-|]必然满⾜条件, 同理, arr[i..j]中的每⼀个⼦数组都满⾜条件　　</li>
</ul>
</li>
<li>如果⼦数组 arr[i..j]不满⾜条件, 那么所有包含 arr[i..j]的⼦数组, 即arr<a href="k&lt;=i&lt;=j&lt;=l">k..l</a>都不满⾜条件</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; minIndexQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; maxIndexQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; array.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; array.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 维护窗口最大值</span></span><br><span class="line">            <span class="keyword">while</span> (!maxIndexQueue.isEmpty() &amp;&amp; array[maxIndexQueue.peekLast()] &lt;= array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                maxIndexQueue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            maxIndexQueue.addLast(j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护窗口最小值</span></span><br><span class="line">            <span class="keyword">while</span> (!minIndexQueue.isEmpty() &amp;&amp; array[minIndexQueue.peekLast()] &gt;= array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                minIndexQueue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            minIndexQueue.addLast(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (array[maxIndexQueue.getFirst()] - array[minIndexQueue.getFirst()] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndexQueue.peekFirst() == i)</span><br><span class="line">        &#123;</span><br><span class="line">            minIndexQueue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxIndexQueue.peekFirst() == i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxIndexQueue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        result += j - i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode-560-和为K的子数组"><a href="#LeetCode-560-和为K的子数组" class="headerlink" title="LeetCode 560 和为K的子数组"></a>LeetCode 560 和为K的子数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode链接</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :<br>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p>
<p>说明：<br>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：前缀和（截取法）"><a href="#解法一：前缀和（截取法）" class="headerlink" title="解法一：前缀和（截取法）"></a>解法一：前缀和（截取法）</h3><ul>
<li>在涉及连续子数组问题的时候，常常可以使用前缀和来解决它们。<ul>
<li>如线段 A..B..C，BC的长度 = AC的长度 - AB的长度</li>
</ul>
</li>
<li>那么在计算位于两个索引之间的元素之和时，我们可以减去对应于两个索引的累积和以直接获得总和。</li>
<li>设sum[i]表示数组从序号0到i-1的元素的和，即sum[i] = A[0] + A[1] + … + A[i-1]</li>
<li>则，子数组 nums [i:j] 的元素总和 = sum [j + 1] - sum [i]</li>
<li>实际上也是动态规划<ul>
<li>dp[i] = dp[i - 1] + nums[i - 1];</li>
</ul>
</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySumWithCache</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sinceCurrentSumArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    sinceCurrentSumArray[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理，构造和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sinceCurrentSumArray[i] = sinceCurrentSumArray[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sinceCurrentSumArray[j] - sinceCurrentSumArray[i] == k)</span><br><span class="line">            &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法二：Map查找"><a href="#解法二：Map查找" class="headerlink" title="解法二：Map查找"></a>解法二：Map查找</h3><ul>
<li>基于以上截取法，设sum[i] = A[0] + A[1] + … + A[i-1]，则子数组 nums [i:j] 的元素总和 = sum [j + 1] - sum [i]</li>
<li>则问题演变为，给定一个数组，是否存在两个元素的差 = K，如果存在，问这样的元素有多少对</li>
<li>那么，我们构造这样的结构 (sum[i], sum[i]出现的次数) 的(key, value)对，当后面遍历的时候，只需搜索前面是否出现了 key = sum[j] - k 的元素对，累加对应的出现次数即可。</li>
</ul>
<p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySumWithMap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i]; <span class="comment">// 这里也可以与解法一结合，先用一个for循环用数组记录了所有sum，这里只顾搜索</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(sum - k))</span><br><span class="line">        &#123;</span><br><span class="line">            result += map.get(sum - k);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode-523-连续的子数组和"><a href="#LeetCode-523-连续的子数组和" class="headerlink" title="LeetCode 523 连续的子数组和"></a>LeetCode 523 连续的子数组和</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">链接</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 <figure class="highlight plain"><figcaption><span>n 也是一个整数。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [23,2,4,6,7], k = 6</span><br><span class="line">输出: True</span><br><span class="line">解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [23,2,6,4,7], k = 6</span><br><span class="line">输出: True</span><br><span class="line">解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">数组的长度不会超过10,000。</span><br><span class="line">你可以认为所有数字总和在 32 位有符号整数范围内。</span><br><span class="line"></span><br><span class="line">## 解法 ##</span><br><span class="line"></span><br><span class="line">### 解法一：前缀和（截取） ###</span><br><span class="line">+ 设sum[i] = A[0] + A[1] + ... + A[i]，则nums[i..j]的和 = sum[j] - sum[i] + nums[i]（注意，与上题有一点不一样）</span><br><span class="line">+ **注意，这里子数组的长度至少为2，在使用前缀和方法的时候，要注意sum数组的长度，是nums.length还是nums.length+1，对应双重for循环遍历的时候，i和j的边界取值问题。**</span><br><span class="line">代码：</span><br><span class="line">```java</span><br><span class="line">public boolean checkSubArraySum(int[] nums, int k)</span><br><span class="line">&#123;</span><br><span class="line">    int[] sum = new int[nums.length];</span><br><span class="line">    sum[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i - 1] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int sumFromIToJ = sum[j] - sum[i] + nums[i];</span><br><span class="line">            if (sumFromIToJ == k || ((k != 0) &amp;&amp; (sumFromIToJ % k == 0)))</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解法二：Map查找-1"><a href="#解法二：Map查找-1" class="headerlink" title="解法二：Map查找"></a>解法二：Map查找</h3><ul>
<li>同样的，基于截取法，设j&gt;i，要看是否存在sum[i..j] == nk，sum[i..j]可以看做sum[0..j] - sum[0..i]，即 sum[0..j] - sum[0..i] == nk</li>
<li>到这里，可以想到map的key应该存放的是遍历到目前为止的sum，当遍历到j的时候，只需要看map中是否存在另一个元素的key使得sum[0..j] == sum[0..i] + nk，看到a=nk+b或者a=b-nk这种式子，就应该要想到同余定理，即 <strong>如果 a%b = c, 则有(a+kb)%b = c; (k为非0整数)</strong>，直接算不好算，那么可以把sum对k取余数，key存这个余数，当遍历到j时，就看map中是否存在其他元素的key与此时的key相同。（key为sum%k）</li>
<li>采用逆推法，设遍历到i的时候和为sumi，假设存在和为nk的子数组，且以i为左端起始，j为右端结尾，那么遍历到j时的和位sumi + nk，根据同余定理，(sumi +nk) % k = sumi % k，如果key存的是截止到当前遍历位置的sum%k，以后就只需判断是否存在相同的key即可，因为存在相同的key时反过来推可以推出这一段子数组的和是nk</li>
<li>由于还要判断子数组长度是否至少为2，因此value可以存数组index序号，value相减来判断是否满足长度至少为2</li>
<li><strong>同余定理</strong>在解题中有很大帮助</li>
<li>采用map查找方法时，要注意初始化map</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubArraySumByMap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum % k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(sum))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - map.get(sum) &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode-974-和可被-K-整除的子数组"><a href="#LeetCode-974-和可被-K-整除的子数组" class="headerlink" title="LeetCode 974 和可被 K 整除的子数组"></a>LeetCode 974 和可被 K 整除的子数组</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">LeetCode链接</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>
<p>示例：<br>输入：A = [4,5,0,-2,-3,1], K = 5<br>输出：7<br>解释：<br>有 7 个子数组满足其元素之和可被 K = 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p>
<p>提示：<br>1 &lt;= A.length &lt;= 30000<br>-10000 &lt;= A[i] &lt;= 10000<br>2 &lt;= K &lt;= 10000</p>
<h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：前缀和（截取法）-1"><a href="#解法一：前缀和（截取法）-1" class="headerlink" title="解法一：前缀和（截取法）"></a>解法一：前缀和（截取法）</h3><ul>
<li>时间复杂度O(N²)，空间复杂度O(N)，此题用该方法超时了</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraysDivByK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sinceCurrentSumArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length + <span class="number">1</span>];</span><br><span class="line">    sinceCurrentSumArray[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sinceCurrentSumArray[i] = sinceCurrentSumArray[i - <span class="number">1</span>] + array[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= array.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sinceCurrentSumArray[j] - sinceCurrentSumArray[i]) % k == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二：Map查找法"><a href="#解法二：Map查找法" class="headerlink" title="解法二：Map查找法"></a>解法二：Map查找法</h2><ul>
<li>在方法一中我们利用前缀和数组来求解问题，对于子数组nums[i..j]，（不包含下标j)，其区间和为sum[j] - sum[i]，(其中sum为预处理得到的前缀和数组),</li>
<li>我们要判断的是(sum[j]−sum[i])%K是否等于0。<ul>
<li>根据mod运算的性质，我们知道 (sum[j]−sum[i])%K = sum[j]%K−sum[i]%K。</li>
<li>故若想(sum[j]−sum[i])%K=0，则必有 sum[j]%K = sum[i]%K。</li>
<li>所有满足nums[i:j]中元素之和可以被K整除的开始下标i，必有sum[j]%K = sum[i]%K。我们以sum[i]%K作为键值统计其出现的频率，从而对于每个下标j我们可以立即获得能和它组成满足要求的子数组的开始下标i的数量。</li>
</ul>
</li>
<li>坑：<strong>由于数组中有可能出现负数，我们需要将其加KK从而使其%K之后的值为正数</strong></li>
<li>时间复杂度: O(N)，空间复杂度: O(K)</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraysDivByKWithMap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += array[i];</span><br><span class="line">        <span class="keyword">int</span> key = (sum % k + k) % k;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            result += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode-713-乘积小于K的子数组"><a href="#LeetCode-713-乘积小于K的子数组" class="headerlink" title="LeetCode 713 乘积小于K的子数组"></a>LeetCode 713 乘积小于K的子数组</h1><h2 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">LeetCode链接</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数数组 nums。</p>
<p>找出该数组内乘积小于 k 的连续的子数组的个数。</p>
<p>示例 1:<br>输入: nums = [10,5,2,6], k = 100<br>输出: 8<br>解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</p>
<p>说明:<br>0 &lt; nums.length &lt;= 50000<br>0 &lt; nums[i] &lt; 1000<br>0 &lt;= k &lt; 10^6</p>
<h1 id="LeetCode-795-区间子数组个数"><a href="#LeetCode-795-区间子数组个数" class="headerlink" title="LeetCode 795 区间子数组个数"></a>LeetCode 795 区间子数组个数</h1><h2 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/" target="_blank" rel="noopener">LeetCode链接</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个元素都是正整数的数组A ，正整数 L 以及 R (L &lt;= R)。<br>求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。</p>
<p>例如 :<br>输入:<br>A = [2, 1, 4, 3]<br>L = 2<br>R = 3<br>输出: 3<br>解释: 满足条件的子数组: [2], [2, 1], [3].</p>
<p>注意:<br>L, R  和 A[i] 都是整数，范围在 [0, 10^9]。<br>数组 A 的长度范围在[1, 50000]。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/10/24/LeetCode-子数组题型总结/" data-id="ck3hazo8m000pwoubswnoi82t" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuUlEQVR42u3aQW7DMAwEwPz/0ynQU4HGyS4lpSkwOgWua2t0kGiSt1s87t/j+ZWf19v7Z3duG3h4eHijqV+Nq3vy//09uau/Jm9p34uHh4d3jvd8I87B+S69d4Eur+Ph4eH9Ke950JxMNwckc8DDw8P7L7z8xcmi5JPGw8PD+zRekg5IkryzJGweah/MteDh4eHFvLYA9gm/D9b38PDw8Baq6m1Sdfa0WWEsej4eHh7eAV7SFtA2Y7VtWLtOtuKLAQ8PD2+Bt5KKTbb49lBpF/3Fbzw8PLzDvJU2grYxK0+/5s9/cAUPDw/vMG/2guQYyNsCkiC7mDMeHh7eAd6sCWAl85ED8iUr5omHh4e3iddOZVbiSqaSY4rDCQ8PD28rry19JemAfOonSm54eHh47+fNpr4SLu+68zLXgoeHh7eV1yYX2kRqHqyvp5KXBh4eHt6I1yYR2naoFeQs9MfDw8M7wVsJpvM0bnvAtIH+i6YrPDw8vAO8lSaAZCvPj5n2NHtxYODh4eEd5rXJ0DahkCcXthXk8PDw8A7zZoHySuE/n3R7PODh4eGd4+UBcZucbbf4WZgeLQ0eHh7eAV6bYG1D4WSjT4pkbWoYDw8P7wRvZep5UT8pZc2WKWodwMPDw9vKyz/ydzVa7UoB14cQHh4e3iZenrRNmqJmSY08iK9bsvDw8PDewpuFy3maNd/uZ01dD74Y8PDw8Lby9pag7vFoWwHydoRbfiseHh7eiHcvx6w5YNY6sJIOLr4Y8PDw8EpeG/KuNE7lRbVZQwMeHh7eO3n5YdBW1VbC5bqC97xpAA8PD+8Ab9cWv75MwzwKHh4e3kfy8q25PSTylER9Jx4eHt4H8NrDIH/XSuPX5ZLh4eHhHeOthMJ549Rs0rNSGR4eHt453uwjf5bCyBclCbiXSHh4eHgT3hcGOGnOC/6hJAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/算法/">算法</a><a href="/tags/LeetCode/">LeetCode</a></div><div class="post-nav"><a class="pre" href="/2019/10/28/树的相关知识点（一）/">树的相关知识点（一）</a><a class="next" href="/2019/09/29/《大型网站技术架构：核心原理与案例分析》读书笔记/">《大型网站技术架构：核心原理与案例分析》读书笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://dcrunnn.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/27/设计模式理论篇-桥接模式/">设计模式理论篇 | 桥接模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/27/算法-最长公共子序列/">算法 | 最长公共子序列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/算法-直方图和0-1矩阵中最大子矩阵/">算法 | 直方图和0-1矩阵中最大子矩阵</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/大数据理论篇-分布式资源管理框架YARN/">大数据理论篇 | 分布式资源管理框架YARN</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/设计模式理论篇-享元模式/">设计模式理论篇 | 享元模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/大数据理论篇-分布式文件系统HDFS/">大数据理论篇 | 分布式文件系统HDFS</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/设计模式理论篇-状态模式/">设计模式理论篇 | 状态模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/设计模式理论篇-策略模式/">设计模式理论篇 | 策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/设计模式理论篇-代理模式/">设计模式理论篇 | 代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/24/设计模式理论篇-外观模式/">设计模式理论篇 | 外观模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>