<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>JVM学习之路 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM学习之路</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM学习之路</h1><div class="post-meta">Jul 4, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一）JDK、JRE和JVM对比"><span class="toc-text">一）JDK、JRE和JVM对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JDK"><span class="toc-text">1.1 JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JRE"><span class="toc-text">1.2 JRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-JVM"><span class="toc-text">1.3 JVM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二）JVM的特点"><span class="toc-text">二）JVM的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三）-JVM字节码"><span class="toc-text">三） JVM字节码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四）-JVM类加载机制"><span class="toc-text">四） JVM类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-什么是类的加载"><span class="toc-text">4.1 什么是类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-加载-class文件的方式"><span class="toc-text">4.2 加载.class文件的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-类的生命周期"><span class="toc-text">4.3 类的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-类加载过程"><span class="toc-text">4.4 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程一：加载"><span class="toc-text">类加载过程一：加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程二：连接"><span class="toc-text">类加载过程二：连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-验证"><span class="toc-text">1) 验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-准备"><span class="toc-text">2) 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-解析"><span class="toc-text">3) 解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程三：初始化"><span class="toc-text">类加载过程三：初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-结束生命周期"><span class="toc-text">4.5 结束生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-类的主动引用和被动引用"><span class="toc-text">4.6 类的主动引用和被动引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主动引用"><span class="toc-text">主动引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被动引用"><span class="toc-text">被动引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-三种类加载器"><span class="toc-text">4.7 三种类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器分类"><span class="toc-text">类加载器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的关系"><span class="toc-text">类加载器的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的特点"><span class="toc-text">类加载器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM类加载机制"><span class="toc-text">JVM类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的隔离问题"><span class="toc-text">类加载器的隔离问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-双亲委派模型"><span class="toc-text">4.8 双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-类的动态加载"><span class="toc-text">4.9 类的动态加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-对象初始化顺序"><span class="toc-text">4.10 对象初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-自定义类加载器"><span class="toc-text">4.11 自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五）JVM内存结构"><span class="toc-text">五）JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-程序计数器（线程私有）"><span class="toc-text">5.1 程序计数器（线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Java虚拟机栈（线程私有）"><span class="toc-text">5.2 Java虚拟机栈（线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-本地方法栈（线程私有）"><span class="toc-text">5.3 本地方法栈（线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-堆（Heap-线程共享）"><span class="toc-text">5.4 堆（Heap-线程共享）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-方法区（线程共享）"><span class="toc-text">5.5 方法区（线程共享）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六）Java垃圾回收"><span class="toc-text">六）Java垃圾回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七）JVM线程与原生线程的关系"><span class="toc-text">七）JVM线程与原生线程的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八）JVM性能调优"><span class="toc-text">八）JVM性能调优</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h1 id="一）JDK、JRE和JVM对比"><a href="#一）JDK、JRE和JVM对比" class="headerlink" title="一）JDK、JRE和JVM对比"></a>一）JDK、JRE和JVM对比</h1><p>JVM，JRE，JDK 都是 java 语言的支柱，他们分工协作。但不同的是 Jdk 和 JRE 是真实存在的，而 JVM 是一个抽象的概念，并不真实存在。</p>
<h2 id="1-1-JDK"><a href="#1-1-JDK" class="headerlink" title="1.1 JDK"></a>1.1 JDK</h2><p>JDK：Java Development Kit，是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合。JDK本体也是Java程序，因此运行依赖于JRE,由于需要保持JDK的独立性与完整性，JDK的安装目录下通常也附有JRE。目前Oracle提供的Windows下的JDK安装工具会同时安装一个正常的JRE和隶属于JDK目录下的JRE。</p>
<h2 id="1-2-JRE"><a href="#1-2-JRE" class="headerlink" title="1.2 JRE"></a>1.2 JRE</h2><p>JRE：Java Runtime Environment，即Java 运行时环境，JRE 是物理存在的，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。</p>
<h2 id="1-3-JVM"><a href="#1-3-JVM" class="headerlink" title="1.3 JVM"></a>1.3 JVM</h2><p>JVM是一种用于计算设备的规范，它是一个虚构的计算机的软件实现，简单的说，JVM是运行byte code字节码程序的一个容器。<br>JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆，和一个存储方法域。<br>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。<br>JVM执行字节码时实际上还是要解释成具体操作平台的机器指令的。<br>通过JVM，Java实现了平台无关性，Java语言在不同平台运行时不需要重新编译，只需要在该平台上部署JVM就可以了。因而能实现一次编译多处运行。(就像是你的虚拟机也可以在任何安了VMWare的系统上运行)</p>
<h1 id="二）JVM的特点"><a href="#二）JVM的特点" class="headerlink" title="二）JVM的特点"></a>二）JVM的特点</h1><ol>
<li>基于堆栈的虚拟机：最流行的计算机体系结构，如英特尔 X86 架构和 ARM 架构上运行基于寄存器。比如，安卓的 Davilk 虚拟机就是基于寄存器 结构，而 JVM 是基于栈结构的。</li>
<li>符号引用 ：除了基本类型以外的数据（类和接口）都是通过符号来引用，而不是通过显式地使用内存地址来引用。</li>
<li>垃圾收集 ：一个类的实例是由用户程序创建和垃圾回收自动销毁。</li>
<li>网络字节顺序 ：Java class文件用网络字节码顺序来进行存储，保证了小端的Intel x86架构和大端的RISC系列的架构之间的无关性。</li>
</ol>
<h1 id="三）-JVM字节码"><a href="#三）-JVM字节码" class="headerlink" title="三） JVM字节码"></a>三） JVM字节码</h1><p>JVM使用Java字节码的方式，作为Java 用户语言和机器语言之间的中间语言。实现一个通用的、 机器无关的执行平台。</p>
<h1 id="四）-JVM类加载机制"><a href="#四）-JVM类加载机制" class="headerlink" title="四） JVM类加载机制"></a>四） JVM类加载机制</h1><h2 id="4-1-什么是类的加载"><a href="#4-1-什么是类的加载" class="headerlink" title="4.1 什么是类的加载"></a>4.1 什么是类的加载</h2><p>简而言之，类加载器就是用于把.class文件中的字节码信息转化为具体的java.lang.Class对象的过程的工具。<br>具体过程：</p>
<ol>
<li>在实际类加载过程中，JVM会将所有的.class字节码文件中的<strong>二进制数据</strong>读入内存中，将其导入到运行时数据区的<strong>方法区</strong>中。</li>
<li>当一个类首次被<strong>主动加载</strong>或<strong>被动加载</strong>时，类加载器会对此类执行类加载的流程 – <strong>加载、连接（验证、准备、解析）、初始化</strong>。</li>
<li>如果类加载成功，会在<strong>堆内存中</strong>会创建一个新的java.lang.Class对象，该Class对象封装了类在<strong>方法区</strong>内的<strong>数据结构</strong>。</li>
</ol>
<p>说明：</p>
<ol>
<li>类的加载的最终产品是位于堆区中的 Class对象</li>
<li>Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</li>
<li>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</li>
</ol>
<h2 id="4-2-加载-class文件的方式"><a href="#4-2-加载-class文件的方式" class="headerlink" title="4.2 加载.class文件的方式"></a>4.2 加载.class文件的方式</h2><ol>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ol>
<h2 id="4-3-类的生命周期"><a href="#4-3-类的生命周期" class="headerlink" title="4.3 类的生命周期"></a>4.3 类的生命周期</h2><p>类的生命周期：</p>
<ol>
<li>加载（Loading）</li>
<li>连接<br>2.1 验证（Verification）<br>2.2 准备（preparation）<br>2.3 解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Use）</li>
<li>卸载（Unloading）</li>
</ol>
<p>其中，加载、连接、初始化归属于类的加载过程，连接又分为验证、准备、解析三个子过程。</p>
<h2 id="4-4-类加载过程"><a href="#4-4-类加载过程" class="headerlink" title="4.4 类加载过程"></a>4.4 类加载过程</h2><p>类加载的过程分为三个步骤(五个阶段) ：<strong>加载 -&gt; 连接（验证、准备、解析）-&gt; 初始化</strong>。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br><strong>加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段可以在初始化阶段之后发生，也称为动态绑定或晚期绑定。</strong></p>
<h3 id="类加载过程一：加载"><a href="#类加载过程一：加载" class="headerlink" title="类加载过程一：加载"></a>类加载过程一：加载</h3><p>加载：查找并加载类的二进制数据的过程</p>
<ul>
<li>加载的过程描述 </li>
</ul>
<ol>
<li>通过类的<strong>全限定名</strong>定位.class文件，并获取其<strong>二进制字节流</strong>。</li>
<li>把<strong>字节流</strong>所代表的<strong>静态存储结构</strong>转换为<strong>方法区</strong>的<strong>运行时数据结构</strong>。</li>
<li>在<strong>Java堆</strong>中生成一个此类的java.lang.Class对象，作为<strong>方法区</strong>中这些数据的访问入口。</li>
</ol>
<h3 id="类加载过程二：连接"><a href="#类加载过程二：连接" class="headerlink" title="类加载过程二：连接"></a>类加载过程二：连接</h3><p>连接：包括 验证、准备、解析 三个步骤 </p>
<h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1) 验证"></a>1) 验证</h4><p>验证：确保被加载的类的正确性。验证是连接阶段的第一步，用于确保Class字节流中的信息是否符合虚拟机的要求。</p>
<ul>
<li>具体验证形式</li>
</ul>
<ol>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ol>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2) 准备"></a>2) 准备</h4><p>准备：为类的<strong>静态变量</strong>分配内存，并将其<strong>初始化</strong>为默认值。准备过程通常分配一个结构用来存储类信息，这个结构中包含了类中定义的<strong>成员变量</strong>，<strong>方法</strong>和<strong>接口信息</strong>等。</p>
<ul>
<li>具体行为</li>
</ul>
<ol>
<li>这时候进行内存分配的仅包括<strong>类变量</strong>(static)，而不包括<strong>实例变量</strong>，<strong>实例变量</strong>会在<strong>对象实例化</strong>时随着对象一块分配在<strong>Java堆</strong>中。</li>
<li>这里所设置的<strong>初始值</strong>通常情况下是数据类型<strong>默认的零值</strong>（如0、0L、null、false等），而不是被在Java代码中被<strong>显式赋值</strong>。</li>
</ol>
<h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3) 解析"></a>3) 解析</h4><p>解析：把类中对<strong>常量池</strong>内的<strong>符号引用</strong>转换为<strong>直接引用</strong>。<br>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄</strong>和<strong>调用点限定符</strong>等7类符号引用进行。</p>
<h3 id="类加载过程三：初始化"><a href="#类加载过程三：初始化" class="headerlink" title="类加载过程三：初始化"></a>类加载过程三：初始化</h3><p>初始化：对<strong>类静态变量</strong>赋予正确的初始值 (注意和连接时的解析过程区分开)。</p>
<ul>
<li>初始化的目标</li>
</ul>
<ol>
<li>实现对声明<strong>类静态变量</strong>时指定的初始值的初始化；</li>
<li>实现对使用<strong>静态代码块</strong>设置的初始值的初始化。</li>
</ol>
<ul>
<li>初始化的步骤</li>
</ul>
<ol>
<li>如果此类没被<strong>加载、连接</strong>，则<strong>先加载、连接此类</strong></li>
<li>如果此类的<strong>直接父类</strong>还未被初始化，则先<strong>初始化其直接父类</strong></li>
<li>如果类中有<strong>初始化语句</strong>，则<strong>按照顺序依次执行初始化语句</strong></li>
</ol>
<ul>
<li>初始化的时机</li>
</ul>
<ol>
<li>创建类的实例(new关键字)</li>
<li>java.lang.reflect包中的方法(如：Class.forName(“xxx”))</li>
<li>对类的静态变量进行访问或赋值</li>
<li>访问调用类的静态方法</li>
<li>初始化一个类的子类，父类本身也会被初始化</li>
<li>作为程序的启动入口，包含main方法(如：SpringBoot入口类)。</li>
</ol>
<h2 id="4-5-结束生命周期"><a href="#4-5-结束生命周期" class="headerlink" title="4.5 结束生命周期"></a>4.5 结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ol>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ol>
<h2 id="4-6-类的主动引用和被动引用"><a href="#4-6-类的主动引用和被动引用" class="headerlink" title="4.6 类的主动引用和被动引用"></a>4.6 类的主动引用和被动引用</h2><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>主动引用：在类加载阶段，只执行加载、连接操作，不执行初始化操作。</p>
<ul>
<li>主动引用的几种形式</li>
</ul>
<ol>
<li>创建类的实例(new关键字)</li>
<li>java.lang.reflect包中的方法(如：Class.forName(“xxx”))</li>
<li>对类的静态变量进行访问或赋值</li>
<li>访问调用类的静态方法</li>
<li>初始化一个类的子类，父类本身也会被初始化</li>
<li>作为程序的启动入口，包含main方法(如：SpringBoot入口类)</li>
</ol>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>被动引用： 在类加载阶段，会执行加载、连接和初始化操作。</p>
<ul>
<li>被动引用的几种形式： </li>
</ul>
<ol>
<li>通过子类引用父类的的静态字段，不会导致子类初始化</li>
<li>定义类的数组引用而不赋值，不会触发此类的初始化</li>
<li>访问类定义的常量，不会触发此类的初始化</li>
</ol>
<h2 id="4-7-三种类加载器"><a href="#4-7-三种类加载器" class="headerlink" title="4.7 三种类加载器"></a>4.7 三种类加载器</h2><p>类加载器：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字予以标识。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="/images/JVM类加载器类型.png" alt=""></p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ol>
<li><strong>启动类加载器</strong>： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：<br>1、在执行非置信代码之前，自动验证数字签名。<br>2、动态地创建符合用户特定需要的定制化构建类。<br>3、从特定的场所取得java class，例如数据库中和网络中。  </p>
<h3 id="类加载器的关系"><a href="#类加载器的关系" class="headerlink" title="类加载器的关系"></a>类加载器的关系</h3><ol>
<li>Bootstrap Classloader 是在Java虚拟机启动后初始化的。</li>
<li>Bootstrap Classloader 负责加载 ExtClassLoader，并且将 ExtClassLoader的父加载器设置为 Bootstrap Classloader</li>
<li>Bootstrap Classloader 加载完 ExtClassLoader 后，就会加载 AppClassLoader，并且将 AppClassLoader 的父加载器指定为 ExtClassLoader。</li>
</ol>
<h3 id="类加载器的特点"><a href="#类加载器的特点" class="headerlink" title="类加载器的特点"></a>类加载器的特点</h3><ol>
<li>层级结构：Java里的类装载器被组织成了有父子关系的层级结构。Bootstrap类装载器是所有装载器的父亲。</li>
<li>代理模式： 基于层级结构，类的代理可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它在父装载器中是否进行了装载。如果上层装载器已经装载了这个类，这个类会被直接使用。反之，类装载器会请求装载这个类</li>
<li>可见性限制：一个子装载器可以查找父装载器中的类，但是一个父装载器不能查找子装载器里的类。</li>
<li>不允许卸载：类装载器可以装载一个类但是不可以卸载它，不过可以删除当前的类装载器，然后创建一个新的类装载器装载</li>
</ol>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ol>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ol>
<h3 id="类加载器的隔离问题"><a href="#类加载器的隔离问题" class="headerlink" title="类加载器的隔离问题"></a>类加载器的隔离问题</h3><p>每个类装载器都有一个自己的命名空间用来保存已装载的类。当一个类装载器装载一个类时，它会通过保存在命名空间里的类全局限定名(Fully Qualified Class Name) 进行搜索来检测这个类是否已经被加载了。<br>JVM 及 Dalvik 对类唯一的识别是 <strong>ClassLoader id + PackageName + ClassName</strong>，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个类不是由一个 ClassLoader 加载，是无法将一个类的实例强转为另外一个类的，这就是 ClassLoader 隔离性。</p>
<p>为了解决类加载器的隔离问题，JVM引入了双亲委托机制。</p>
<h2 id="4-8-双亲委派模型"><a href="#4-8-双亲委派模型" class="headerlink" title="4.8 双亲委派模型"></a>4.8 双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>核心思想：<strong>其一，自底向上检查类是否已加载；其二，自顶向下尝试加载类</strong>。</p>
<p><strong>具体加载过程</strong></p>
<ol>
<li>当<strong>AppClassLoader</strong>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<strong>ExtClassLoader</strong>去完成。</li>
<li>当<strong>ExtClassLoader</strong>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果<strong>BootStrapClassLoader</strong>加载失败（例如在%JAVA_HOME%/jre/lib里未查找到该class），会使用<strong>ExtClassLoader</strong>来尝试加载；</li>
<li>如果<strong>ExtClassLoader</strong>也加载失败，则会使用<strong>AppClassLoader</strong>来加载，如果<strong>AppClassLoader</strong>也加载失败，则会报出异常<strong>ClassNotFoundException</strong>。</li>
</ol>
<p><strong>双亲委派模型意义</strong>：</p>
<ol>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ol>
<h2 id="4-9-类的动态加载"><a href="#4-9-类的动态加载" class="headerlink" title="4.9 类的动态加载"></a>4.9 类的动态加载</h2><p><strong>类加载方式</strong><br>1、命令行启动应用时候由JVM初始化加载<br>2、通过Class.forName()方法动态加载<br>3、通过ClassLoader.loadClass()方法动态加载</p>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ol>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ol>
<h2 id="4-10-对象初始化顺序"><a href="#4-10-对象初始化顺序" class="headerlink" title="4.10 对象初始化顺序"></a>4.10 对象初始化顺序</h2><p>(七). 对象的初始化<br>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p>
<ol>
<li>父类静态变量和静态代码块（先声明的先执行）</li>
<li>子类静态变量和静态代码块（先声明的先执行）</li>
<li>父类普通成员变量和普通代码块（先声明的先执行）</li>
<li>父类的构造函数</li>
<li>子类普通成员变量和普通代码块（先声明的先执行）</li>
<li>子类的构造函数</li>
</ol>
<h2 id="4-11-自定义类加载器"><a href="#4-11-自定义类加载器" class="headerlink" title="4.11 自定义类加载器"></a>4.11 自定义类加载器</h2><h1 id="五）JVM内存结构"><a href="#五）JVM内存结构" class="headerlink" title="五）JVM内存结构"></a>五）JVM内存结构</h1><h2 id="5-1-程序计数器（线程私有）"><a href="#5-1-程序计数器（线程私有）" class="headerlink" title="5.1 程序计数器（线程私有）"></a>5.1 程序计数器（线程私有）</h2><h2 id="5-2-Java虚拟机栈（线程私有）"><a href="#5-2-Java虚拟机栈（线程私有）" class="headerlink" title="5.2 Java虚拟机栈（线程私有）"></a>5.2 Java虚拟机栈（线程私有）</h2><h2 id="5-3-本地方法栈（线程私有）"><a href="#5-3-本地方法栈（线程私有）" class="headerlink" title="5.3 本地方法栈（线程私有）"></a>5.3 本地方法栈（线程私有）</h2><h2 id="5-4-堆（Heap-线程共享）"><a href="#5-4-堆（Heap-线程共享）" class="headerlink" title="5.4 堆（Heap-线程共享）"></a>5.4 堆（Heap-线程共享）</h2><h2 id="5-5-方法区（线程共享）"><a href="#5-5-方法区（线程共享）" class="headerlink" title="5.5 方法区（线程共享）"></a>5.5 方法区（线程共享）</h2><h1 id="六）Java垃圾回收"><a href="#六）Java垃圾回收" class="headerlink" title="六）Java垃圾回收"></a>六）Java垃圾回收</h1><h1 id="七）JVM线程与原生线程的关系"><a href="#七）JVM线程与原生线程的关系" class="headerlink" title="七）JVM线程与原生线程的关系"></a>七）JVM线程与原生线程的关系</h1><h1 id="八）JVM性能调优"><a href="#八）JVM性能调优" class="headerlink" title="八）JVM性能调优"></a>八）JVM性能调优</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>类加载部分：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/43845064" target="_blank" rel="noopener">JVM系列(五) - JVM类加载机制详解</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/07/04/JVM详解/" data-id="cjy1csudk00069kubt9siz54a" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOElEQVR42u3a0W6DMAxGYd7/pdntpA16fhsqxTm5qiYK+Zjk2rGPA6/z1/r796vPV9+6v8P99a0lQ4aMZRnn7eLbqlHT13G5BxkyZGzAIKHwnnQFqF3P9yZDhgwZ5BoSpsn16XNlyJAhgwTcWnVZSyVlyJAhg6dxPAVMy90v1eIyZMhYkMGD5vc/v9LfkCFDxlKMM1y1ozfSwuRB9p8nypAhYzSDBzi+UZ66BQUqSS5lyJCxAeOp0Ye01EwP4NBxmwwZMoYyeChM07404eMv98PvhgwZMkYwSFhMD8LSwS9eDCd5ogwZMuYw7kNh7QSevywyHBYc5MmQIWMog2wlzTRrYxm1sY/g/yBDhoxlGbyI5SG41lroj33IkCFjKqPTDOBpXCdAoxaCDBkyNmDUDt3SAYvO8FkwZiFDhoxxDF5q8pqxcwzHhy2O2oZkyJCxIIMfsdVam+RArdMc/TBsIUOGjBGMNO17L/iSe6I8V4YMGUMZj3UYSslfp4SWIUPGbox+KftGyfrYyIUMGTIWZ/CEj7ch01EznqRe7lCGDBkbMDrlK2lGpiE7PpKTIUPGZgwSIkm4JKlnp4SWIUPGDowzXJ1v1WYkgvpbhgwZQxlpmCOFa+0OJHCnT5QhQ8YkBg+yPAVMi960IRH/esiQIWMEIw18/HAtHado1eIyZMiQUUoZa9fzdoIMGTJkpGMQfTDHxzMjMmTIWJzRSfjSJLLWDJAhQ8bOjLR0TDfHt5sOqMmQIWMDxg887omHejEFjQAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/知识/">知识</a></div><div class="post-nav"><a class="pre" href="/2019/07/10/LeetCode-146-LRU缓存机制/">LeetCode-146.LRU缓存机制</a><a class="next" href="/2019/07/03/Java8新的时间和日期API/">Java8新的时间和日期API</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://dcrunnn.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/LeetCode-146-LRU缓存机制/">LeetCode-146.LRU缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/04/JVM详解/">JVM学习之路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/03/Java8新的时间和日期API/">Java8新的时间和日期API</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/Enum的使用/">Enum的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/31/记一次用Map优化if-else的过程/">记一次用Map优化if/else的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/19/Java8中的Stream/">Java8学习积累</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/学习Java线程池/">学习Java线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/02/《Java并发编程的艺术》笔记/">《Java并发编程的艺术》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/用Java8来排排序/">用Java8来排排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/为Maven配置阿里云镜像/">为Maven配置阿里云镜像</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>