<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>JVM学习之路 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM学习之路</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM学习之路</h1><div class="post-meta">Jul 4, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一）JDK、JRE和JVM对比"><span class="toc-text">一）JDK、JRE和JVM对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JDK"><span class="toc-text">1.1 JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JRE"><span class="toc-text">1.2 JRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-JVM"><span class="toc-text">1.3 JVM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二）JVM的特点"><span class="toc-text">二）JVM的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三）-JVM字节码"><span class="toc-text">三） JVM字节码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四）-JVM类加载机制"><span class="toc-text">四） JVM类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-什么是类的加载"><span class="toc-text">4.1 什么是类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-加载-class文件的方式"><span class="toc-text">4.2 加载.class文件的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-类的生命周期"><span class="toc-text">4.3 类的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-类加载过程"><span class="toc-text">4.4 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程一：加载"><span class="toc-text">类加载过程一：加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程二：连接"><span class="toc-text">类加载过程二：连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-验证"><span class="toc-text">1) 验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-准备"><span class="toc-text">2) 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-解析"><span class="toc-text">3) 解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载过程三：初始化"><span class="toc-text">类加载过程三：初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-结束生命周期"><span class="toc-text">4.5 结束生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-类的主动引用和被动引用"><span class="toc-text">4.6 类的主动引用和被动引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主动引用"><span class="toc-text">主动引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#被动引用"><span class="toc-text">被动引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-三种类加载器"><span class="toc-text">4.7 三种类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器分类"><span class="toc-text">类加载器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的关系"><span class="toc-text">类加载器的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的特点"><span class="toc-text">类加载器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM类加载机制"><span class="toc-text">JVM类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的隔离问题"><span class="toc-text">类加载器的隔离问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-双亲委派模型"><span class="toc-text">4.8 双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-类的动态加载"><span class="toc-text">4.9 类的动态加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-对象初始化顺序"><span class="toc-text">4.10 对象初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-自定义类加载器"><span class="toc-text">4.11 自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五）JVM内存结构"><span class="toc-text">五）JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-程序计数器（PC-Program-Counter，线程私有）"><span class="toc-text">5.1 程序计数器（PC, Program Counter，线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Java虚拟机栈（JVM-Stacks，线程私有）"><span class="toc-text">5.2 Java虚拟机栈（JVM Stacks，线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-本地方法栈（Native-Method-Stack，线程私有）"><span class="toc-text">5.3 本地方法栈（Native Method Stack，线程私有）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-堆（Heap，线程共享）"><span class="toc-text">5.4 堆（Heap，线程共享）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-方法区（Method-Area，线程共享）"><span class="toc-text">5.5 方法区（Method Area，线程共享）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六）Java垃圾回收"><span class="toc-text">六）Java垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象存活判断"><span class="toc-text">对象存活判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集算法"><span class="toc-text">垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）标记-清除算法"><span class="toc-text">1）标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）复制算法"><span class="toc-text">2）复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3）标记-整理算法"><span class="toc-text">3）标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4）分代收集算法"><span class="toc-text">4）分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集器"><span class="toc-text">垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七）JAVA-四中引用类型"><span class="toc-text">七）JAVA 四中引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八）JVM线程与原生线程的关系"><span class="toc-text">八）JVM线程与原生线程的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九）JVM性能调优"><span class="toc-text">九）JVM性能调优</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十）Java8中JVM内存的变化"><span class="toc-text">十）Java8中JVM内存的变化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h1 id="一）JDK、JRE和JVM对比"><a href="#一）JDK、JRE和JVM对比" class="headerlink" title="一）JDK、JRE和JVM对比"></a>一）JDK、JRE和JVM对比</h1><p>JVM，JRE，JDK 都是 java 语言的支柱，他们分工协作。但不同的是 Jdk 和 JRE 是真实存在的，而 JVM 是一个抽象的概念，并不真实存在。</p>
<h2 id="1-1-JDK"><a href="#1-1-JDK" class="headerlink" title="1.1 JDK"></a>1.1 JDK</h2><p>JDK：Java Development Kit，是 Java 语言的软件开发工具包（SDK）。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合。JDK本体也是Java程序，因此运行依赖于JRE,由于需要保持JDK的独立性与完整性，JDK的安装目录下通常也附有JRE。目前Oracle提供的Windows下的JDK安装工具会同时安装一个正常的JRE和隶属于JDK目录下的JRE。</p>
<h2 id="1-2-JRE"><a href="#1-2-JRE" class="headerlink" title="1.2 JRE"></a>1.2 JRE</h2><p>JRE：Java Runtime Environment，即Java 运行时环境，JRE 是物理存在的，主要由Java API 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。</p>
<h2 id="1-3-JVM"><a href="#1-3-JVM" class="headerlink" title="1.3 JVM"></a>1.3 JVM</h2><p>JVM是一种用于计算设备的规范，它是一个虚构的计算机的软件实现，简单的说，JVM是运行byte code字节码程序的一个容器。<br>JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆，和一个存储方法域。<br>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。<br>JVM执行字节码时实际上还是要解释成具体操作平台的机器指令的。<br>通过JVM，Java实现了平台无关性，Java语言在不同平台运行时不需要重新编译，只需要在该平台上部署JVM就可以了。因而能实现一次编译多处运行。(就像是你的虚拟机也可以在任何安了VMWare的系统上运行)</p>
<h1 id="二）JVM的特点"><a href="#二）JVM的特点" class="headerlink" title="二）JVM的特点"></a>二）JVM的特点</h1><ol>
<li>基于堆栈的虚拟机：最流行的计算机体系结构，如英特尔 X86 架构和 ARM 架构上运行基于寄存器。比如，安卓的 Davilk 虚拟机就是基于寄存器 结构，而 JVM 是基于栈结构的。</li>
<li>符号引用 ：除了基本类型以外的数据（类和接口）都是通过符号来引用，而不是通过显式地使用内存地址来引用。</li>
<li>垃圾收集 ：一个类的实例是由用户程序创建和垃圾回收自动销毁。</li>
<li>网络字节顺序 ：Java class文件用网络字节码顺序来进行存储，保证了小端的Intel x86架构和大端的RISC系列的架构之间的无关性。</li>
</ol>
<h1 id="三）-JVM字节码"><a href="#三）-JVM字节码" class="headerlink" title="三） JVM字节码"></a>三） JVM字节码</h1><p>JVM使用Java字节码的方式，作为Java 用户语言和机器语言之间的中间语言。实现一个通用的、 机器无关的执行平台。</p>
<h1 id="四）-JVM类加载机制"><a href="#四）-JVM类加载机制" class="headerlink" title="四） JVM类加载机制"></a>四） JVM类加载机制</h1><h2 id="4-1-什么是类的加载"><a href="#4-1-什么是类的加载" class="headerlink" title="4.1 什么是类的加载"></a>4.1 什么是类的加载</h2><p>简而言之，类加载器就是用于把.class文件中的字节码信息转化为具体的java.lang.Class对象的过程的工具。<br>具体过程：</p>
<ol>
<li>在实际类加载过程中，JVM会将所有的.class字节码文件中的<strong>二进制数据</strong>读入内存中，将其导入到运行时数据区的<strong>方法区</strong>中。</li>
<li>当一个类首次被<strong>主动加载</strong>或<strong>被动加载</strong>时，类加载器会对此类执行类加载的流程 – <strong>加载、连接（验证、准备、解析）、初始化</strong>。</li>
<li>如果类加载成功，会在<strong>堆内存中</strong>会创建一个新的java.lang.Class对象，该Class对象封装了类在<strong>方法区</strong>内的<strong>数据结构</strong>。</li>
</ol>
<p>说明：</p>
<ol>
<li>类的加载的最终产品是位于堆区中的 Class对象</li>
<li>Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</li>
<li>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</li>
</ol>
<h2 id="4-2-加载-class文件的方式"><a href="#4-2-加载-class文件的方式" class="headerlink" title="4.2 加载.class文件的方式"></a>4.2 加载.class文件的方式</h2><ol>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ol>
<h2 id="4-3-类的生命周期"><a href="#4-3-类的生命周期" class="headerlink" title="4.3 类的生命周期"></a>4.3 类的生命周期</h2><p>类的生命周期：</p>
<ol>
<li>加载（Loading）</li>
<li>连接<br>2.1 验证（Verification）<br>2.2 准备（preparation）<br>2.3 解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Use）</li>
<li>卸载（Unloading）</li>
</ol>
<p>其中，加载、连接、初始化归属于类的加载过程，连接又分为验证、准备、解析三个子过程。</p>
<h2 id="4-4-类加载过程"><a href="#4-4-类加载过程" class="headerlink" title="4.4 类加载过程"></a>4.4 类加载过程</h2><p>类加载的过程分为三个步骤(五个阶段) ：<strong>加载 -&gt; 连接（验证、准备、解析）-&gt; 初始化</strong>。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。<br><strong>加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段可以在初始化阶段之后发生，也称为动态绑定或晚期绑定。</strong></p>
<h3 id="类加载过程一：加载"><a href="#类加载过程一：加载" class="headerlink" title="类加载过程一：加载"></a>类加载过程一：加载</h3><p>加载：查找并加载类的二进制数据的过程</p>
<ul>
<li>加载的过程描述 </li>
</ul>
<ol>
<li>通过类的<strong>全限定名</strong>定位.class文件，并获取其<strong>二进制字节流</strong>。</li>
<li>把<strong>字节流</strong>所代表的<strong>静态存储结构</strong>转换为<strong>方法区</strong>的<strong>运行时数据结构</strong>。</li>
<li>在<strong>Java堆</strong>中生成一个此类的java.lang.Class对象，作为<strong>方法区</strong>中这些数据的访问入口。</li>
</ol>
<h3 id="类加载过程二：连接"><a href="#类加载过程二：连接" class="headerlink" title="类加载过程二：连接"></a>类加载过程二：连接</h3><p>连接：包括 验证、准备、解析 三个步骤 </p>
<h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1) 验证"></a>1) 验证</h4><p>验证：确保被加载的类的正确性。验证是连接阶段的第一步，用于确保Class字节流中的信息是否符合虚拟机的要求。</p>
<ul>
<li>具体验证形式</li>
</ul>
<ol>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ol>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2) 准备"></a>2) 准备</h4><p>准备：为类的<strong>静态变量</strong>分配内存，并将其<strong>初始化</strong>为默认值。准备过程通常分配一个结构用来存储类信息，这个结构中包含了类中定义的<strong>成员变量</strong>，<strong>方法</strong>和<strong>接口信息</strong>等。</p>
<ul>
<li>具体行为</li>
</ul>
<ol>
<li>这时候进行内存分配的仅包括<strong>类变量</strong>(static)，而不包括<strong>实例变量</strong>，<strong>实例变量</strong>会在<strong>对象实例化</strong>时随着对象一块分配在<strong>Java堆</strong>中。</li>
<li>这里所设置的<strong>初始值</strong>通常情况下是数据类型<strong>默认的零值</strong>（如0、0L、null、false等），而不是被在Java代码中被<strong>显式赋值</strong>。</li>
</ol>
<h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3) 解析"></a>3) 解析</h4><p>解析：把类中对<strong>常量池</strong>内的<strong>符号引用</strong>转换为<strong>直接引用</strong>。<br>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄</strong>和<strong>调用点限定符</strong>等7类符号引用进行。</p>
<h3 id="类加载过程三：初始化"><a href="#类加载过程三：初始化" class="headerlink" title="类加载过程三：初始化"></a>类加载过程三：初始化</h3><p>初始化：对<strong>类静态变量</strong>赋予正确的初始值 (注意和连接时的解析过程区分开)。</p>
<ul>
<li>初始化的目标</li>
</ul>
<ol>
<li>实现对声明<strong>类静态变量</strong>时指定的初始值的初始化；</li>
<li>实现对使用<strong>静态代码块</strong>设置的初始值的初始化。</li>
</ol>
<ul>
<li>初始化的步骤</li>
</ul>
<ol>
<li>如果此类没被<strong>加载、连接</strong>，则<strong>先加载、连接此类</strong></li>
<li>如果此类的<strong>直接父类</strong>还未被初始化，则先<strong>初始化其直接父类</strong></li>
<li>如果类中有<strong>初始化语句</strong>，则<strong>按照顺序依次执行初始化语句</strong></li>
</ol>
<ul>
<li>初始化的时机</li>
</ul>
<ol>
<li>创建类的实例(new关键字)</li>
<li>java.lang.reflect包中的方法(如：Class.forName(“xxx”))</li>
<li>对类的静态变量进行访问或赋值</li>
<li>访问调用类的静态方法</li>
<li>初始化一个类的子类，父类本身也会被初始化</li>
<li>作为程序的启动入口，包含main方法(如：SpringBoot入口类)。</li>
</ol>
<h2 id="4-5-结束生命周期"><a href="#4-5-结束生命周期" class="headerlink" title="4.5 结束生命周期"></a>4.5 结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ol>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ol>
<h2 id="4-6-类的主动引用和被动引用"><a href="#4-6-类的主动引用和被动引用" class="headerlink" title="4.6 类的主动引用和被动引用"></a>4.6 类的主动引用和被动引用</h2><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>主动引用：在类加载阶段，只执行加载、连接操作，不执行初始化操作。</p>
<ul>
<li>主动引用的几种形式</li>
</ul>
<ol>
<li>创建类的实例(new关键字)</li>
<li>java.lang.reflect包中的方法(如：Class.forName(“xxx”))</li>
<li>对类的静态变量进行访问或赋值</li>
<li>访问调用类的静态方法</li>
<li>初始化一个类的子类，父类本身也会被初始化</li>
<li>作为程序的启动入口，包含main方法(如：SpringBoot入口类)</li>
</ol>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>被动引用： 在类加载阶段，会执行加载、连接和初始化操作。</p>
<ul>
<li>被动引用的几种形式： </li>
</ul>
<ol>
<li>通过子类引用父类的的静态字段，不会导致子类初始化</li>
<li>定义类的数组引用而不赋值，不会触发此类的初始化</li>
<li>访问类定义的常量，不会触发此类的初始化</li>
</ol>
<h2 id="4-7-三种类加载器"><a href="#4-7-三种类加载器" class="headerlink" title="4.7 三种类加载器"></a>4.7 三种类加载器</h2><p>类加载器：类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字予以标识。</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p><img src="/images/JVM类加载器类型.png" alt></p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ol>
<li><strong>启动类加载器</strong>： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：<br>1、在执行非置信代码之前，自动验证数字签名。<br>2、动态地创建符合用户特定需要的定制化构建类。<br>3、从特定的场所取得java class，例如数据库中和网络中。  </p>
<h3 id="类加载器的关系"><a href="#类加载器的关系" class="headerlink" title="类加载器的关系"></a>类加载器的关系</h3><ol>
<li><strong>Bootstrap Classloader</strong>是在Java虚拟机启动后初始化的。</li>
<li><strong>Bootstrap Classloader</strong>负责加载<strong>ExtClassLoader</strong>，并且将<strong>ExtClassLoader</strong>的父加载器设置为<strong>Bootstrap Classloader</strong></li>
<li><strong>Bootstrap Classloader</strong>加载完<strong>ExtClassLoader</strong>后，就会加载<strong>AppClassLoader</strong>，并且将<strong>AppClassLoader</strong>的父加载器指定为<strong>ExtClassLoader</strong>。</li>
</ol>
<h3 id="类加载器的特点"><a href="#类加载器的特点" class="headerlink" title="类加载器的特点"></a>类加载器的特点</h3><ol>
<li>层级结构：Java里的类装载器被组织成了有父子关系的层级结构。Bootstrap类装载器是所有装载器的父亲。</li>
<li>代理模式： 基于层级结构，类的代理可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它在父装载器中是否进行了装载。如果上层装载器已经装载了这个类，这个类会被直接使用。反之，类装载器会请求装载这个类</li>
<li>可见性限制：一个子装载器可以查找父装载器中的类，但是一个父装载器不能查找子装载器里的类。</li>
<li>不允许卸载：类装载器可以装载一个类但是不可以卸载它，不过可以删除当前的类装载器，然后创建一个新的类装载器装载</li>
</ol>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ol>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ol>
<h3 id="类加载器的隔离问题"><a href="#类加载器的隔离问题" class="headerlink" title="类加载器的隔离问题"></a>类加载器的隔离问题</h3><p>每个类装载器都有一个自己的命名空间用来保存已装载的类。当一个类装载器装载一个类时，它会通过保存在命名空间里的类全局限定名(Fully Qualified Class Name) 进行搜索来检测这个类是否已经被加载了。<br>JVM 及 Dalvik 对类唯一的识别是 <strong>ClassLoader id + PackageName + ClassName</strong>，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个类不是由一个 ClassLoader 加载，是无法将一个类的实例强转为另外一个类的，这就是 ClassLoader 隔离性。</p>
<p>为了解决类加载器的隔离问题，JVM引入了<strong>双亲委托机制</strong>。</p>
<h2 id="4-8-双亲委派模型"><a href="#4-8-双亲委派模型" class="headerlink" title="4.8 双亲委派模型"></a>4.8 双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br>核心思想：<strong>其一，自底向上检查类是否已加载；其二，自顶向下尝试加载类</strong>。</p>
<p><strong>具体加载过程</strong></p>
<ol>
<li>当<strong>AppClassLoader</strong>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<strong>ExtClassLoader</strong>去完成。</li>
<li>当<strong>ExtClassLoader</strong>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果<strong>BootStrapClassLoader</strong>加载失败（例如在%JAVA_HOME%/jre/lib里未查找到该class），会使用<strong>ExtClassLoader</strong>来尝试加载；</li>
<li>如果<strong>ExtClassLoader</strong>也加载失败，则会使用<strong>AppClassLoader</strong>来加载，如果<strong>AppClassLoader</strong>也加载失败，则会报出异常<strong>ClassNotFoundException</strong>。</li>
</ol>
<p><strong>双亲委派模型意义</strong>：</p>
<ol>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ol>
<h2 id="4-9-类的动态加载"><a href="#4-9-类的动态加载" class="headerlink" title="4.9 类的动态加载"></a>4.9 类的动态加载</h2><p><strong>类加载方式</strong><br>1、命令行启动应用时候由JVM初始化加载<br>2、通过Class.forName()方法动态加载<br>3、通过ClassLoader.loadClass()方法动态加载</p>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ol>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ol>
<h2 id="4-10-对象初始化顺序"><a href="#4-10-对象初始化顺序" class="headerlink" title="4.10 对象初始化顺序"></a>4.10 对象初始化顺序</h2><p>(七). 对象的初始化<br>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p>
<ol>
<li>父类静态变量和静态代码块（先声明的先执行）</li>
<li>子类静态变量和静态代码块（先声明的先执行）</li>
<li>父类普通成员变量和普通代码块（先声明的先执行）</li>
<li>父类的构造函数</li>
<li>子类普通成员变量和普通代码块（先声明的先执行）</li>
<li>子类的构造函数</li>
</ol>
<h2 id="4-11-自定义类加载器"><a href="#4-11-自定义类加载器" class="headerlink" title="4.11 自定义类加载器"></a>4.11 自定义类加载器</h2><h1 id="五）JVM内存结构"><a href="#五）JVM内存结构" class="headerlink" title="五）JVM内存结构"></a>五）JVM内存结构</h1><p>JVM主要包括：程序计数器(Program Counter)，Java堆(Heap)，Java虚拟机栈(Stack)，本地方法栈(Native Stack)，方法区(Method Area)</p>
<p><strong>JVM内存结构布局：</strong><br><img src="/images/JVM内存模型.png" alt><br><img src="/images/JVM内存模型2.png" alt><br>注：</p>
<ul>
<li>PermGen Space：Permanent Generation space，持久代，是指内存的永久保存区域，也叫方法区。这块内存主要是被JVM存放Class和Meta信息的，Class在被Loader时就会被放到PermGen space中,它和存放类实例(Instance)的Heap区域不同，GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。</li>
<li>Young Generation：年轻代</li>
<li>Old Generation：老年代，也叫Tenured Generation</li>
</ul>
<p>JVM内存结构主要有三大块：堆内存、方法区和栈。</p>
<ul>
<li>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配。</li>
<li>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)。</li>
<li>栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</li>
</ul>
<p><strong>JVM和系统调用之间的关系：</strong><br><img src="/images/JVM和系统调用之间的关系.png" alt><br>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p>
<p>下面详细介绍各区域的作用。</p>
<h2 id="5-1-程序计数器（PC-Program-Counter，线程私有）"><a href="#5-1-程序计数器（PC-Program-Counter，线程私有）" class="headerlink" title="5.1 程序计数器（PC, Program Counter，线程私有）"></a>5.1 程序计数器（PC, Program Counter，线程私有）</h2><ul>
<li>程序计数器是一个寄存器，是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，用于指示跳转下一条需要执行的命令。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</li>
<li>PC存在于JVM Stack上。</li>
<li><strong>PC的内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></li>
</ul>
<h2 id="5-2-Java虚拟机栈（JVM-Stacks，线程私有）"><a href="#5-2-Java虚拟机栈（JVM-Stacks，线程私有）" class="headerlink" title="5.2 Java虚拟机栈（JVM Stacks，线程私有）"></a>5.2 Java虚拟机栈（JVM Stacks，线程私有）</h2><ul>
<li>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</li>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表（Local Variables)、操作栈（Operand Stack）、动态链接（Current Class Constant Pool Reference）、方法出口（Return Value）等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表负责存放以下内容：<ul>
<li>编译期可知的8种基本数据类型（boolean、byte、char、short、int、float、long、double）</li>
<li>对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）</li>
<li>returnAddress类型（指向了一条字节码指令的地址）。</li>
</ul>
</li>
<li>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</li>
<li>操作栈在执行字节码指令时会被用到，这种方式类似于原生的CPU寄存器，大部分JVM把时间花费在操作栈的花费上，操作栈和局部变量数组会频繁的交换数据。</li>
<li>动态连接控制着运行时常量池和栈帧的连接。所有方法和类的引用都会被当作符号的引用存在常量池中。符号引用是实际上并不指向物理内存地址的逻辑引用。JVM 可以选择符号引用解析的时机，一种是当类文件加载并校验通过后，这种解析方式被称为饥饿方式。另外一种是符号引用在第一次使用的时候被解析，这种解析方式称为惰性方式。无论如何，JVM必须要在第一次使用符号引用时完成解析并抛出可能发生的解析错误。绑定是将对象域、方法、类的符号引用替换为直接引用的过程。绑定只会发生一次。一旦绑定，符号引用会被完全替换。如果一个类的符号引用还没有被解析，那么就会载入这个类。每个直接引用都被存储为相对于存储结构（与运行时变量或方法的位置相关联的）偏移量。</li>
<li>在Java虚拟机规范中，对JVM Stack这个区域规定了两种异常状况:<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</li>
</ul>
</li>
</ul>
<h2 id="5-3-本地方法栈（Native-Method-Stack，线程私有）"><a href="#5-3-本地方法栈（Native-Method-Stack，线程私有）" class="headerlink" title="5.3 本地方法栈（Native Method Stack，线程私有）"></a>5.3 本地方法栈（Native Method Stack，线程私有）</h2><ul>
<li>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>
<li>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</li>
<li>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</li>
</ul>
<h2 id="5-4-堆（Heap，线程共享）"><a href="#5-4-堆（Heap，线程共享）" class="headerlink" title="5.4 堆（Heap，线程共享）"></a>5.4 堆（Heap，线程共享）</h2><ul>
<li>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，<strong>几乎所有的对象实例都在这里分配内存</strong>。</li>
<li>Java堆是<strong>垃圾收集器管理的主要区域</strong>，因此很多时候也被称做<strong>“GC堆（Garbage Collection Heap）”</strong>。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代(Young Generation)和老年代(Old Generation/Tenured Generation)；再细致一点的有Eden Space、From Survivor Space、To Survivor Space等</strong>。<br>但无论哪个区域，如何划分，存储的都是Java对象实例，进一步的划分是为了更好的回收内存或快速的分配内存。</li>
<li>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</li>
<li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</li>
</ul>
<h2 id="5-5-方法区（Method-Area，线程共享）"><a href="#5-5-方法区（Method-Area，线程共享）" class="headerlink" title="5.5 方法区（Method Area，线程共享）"></a>5.5 方法区（Method Area，线程共享）</h2><ul>
<li>方法区有时被称为持久代（PermGen），对于存在永久代(Permanent)概念的虚拟机(HotSpot)而言，方法区存在于永久代。</li>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</li>
<li>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</li>
<li>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</li>
<li>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</li>
</ul>
<p><strong>JVM内存模型总结</strong><br><strong>1）各区域存储的内容：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Heap</th>
<th style="text-align:center">Method Area</th>
<th style="text-align:center">Thread 1…N</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">所有线程共享</td>
<td style="text-align:center">所有线程共享</td>
<td style="text-align:center">私有的栈</td>
</tr>
<tr>
<td style="text-align:center">存储所有创建的对象及数组</td>
<td style="text-align:center">存储类结构信息（如属性、方法数据、构造函数、方法的代码等）</td>
<td style="text-align:center">持有堆对象的引用、存储局部变量（原始类型）</td>
</tr>
</tbody>
</table>
<p>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。<br>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。</p>
<p>堆:<br>存储的是对象，每个对象都包含一个与之对应的class。<br>JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。<br>对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定</p>
<p>栈：<br>每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。<br>每个栈中的数据(原始类型和对象引用)都是私有的。<br>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。<br>数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。</p>
<p>方法区：<br>静态区，跟堆一样，被所有的线程共享。<br>方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>
<p>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = Logger.getLogger(HelloWorld.class.getName());</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd.MM.YYYY"</span>);       </span><br><span class="line">    String today = formatter.format(<span class="keyword">new</span> Date());</span><br><span class="line">    LOGGER.info(today + <span class="string">": "</span> + message);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段程序的数据在内存中的存放如下：</p>
<ul>
<li>Heap:<ul>
<li>-Object: HelloWorld</li>
<li>-Object: SimpleDateFormat</li>
<li>-Object: String</li>
<li>-Object: LOGGER</li>
</ul>
</li>
<li>Method Area:<ul>
<li>-Class: SimpleDateFormat<ul>
<li>-…</li>
</ul>
</li>
<li>-Class: Logger<ul>
<li>-…</li>
</ul>
</li>
<li>-Class: HelloWorld<ul>
<li>-Method: sayHello()</li>
<li>-…</li>
</ul>
</li>
</ul>
</li>
<li>Thread 1: main<ul>
<li>-参数引用： “message” to String对象</li>
<li>-变量引用：<ul>
<li>formatter to SimpleDateFormat</li>
<li>today to String</li>
</ul>
</li>
<li>-局部原始类型：行号</li>
</ul>
</li>
</ul>
<p><strong>2）理解OutOfMemoryError</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure></p>
<ul>
<li>原因：对象不能被分配到堆内存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：创建的数组大于堆内存的空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes <span class="keyword">for</span> &lt;reason&gt;. Out of swap space?</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: &lt;reason&gt; &lt;stack trace&gt;（Native method）</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现</li>
</ul>
<h1 id="六）Java垃圾回收"><a href="#六）Java垃圾回收" class="headerlink" title="六）Java垃圾回收"></a>六）Java垃圾回收</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JVM中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于java堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><p>判断对象是否存活一般有两种方式：</p>
<ol>
<li><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li>
<li><strong>可达性分析（Reachability Analysis）</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的不可达对象。</li>
</ol>
<p>在Java语言中，GC Roots包括：</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>垃圾收集算法主要有 <strong>标记-清除算法、复制算法、标记-压缩算法、分代收集算法</strong> 等。<br>其中分代收集法是目前大部分JVM所采用的方法。</p>
<ul>
<li>新生代：复制算法（Copying）</li>
<li>老年代：标记-整理算法（Mark-Compact）</li>
</ul>
<h3 id="1）标记-清除算法"><a href="#1）标记-清除算法" class="headerlink" title="1）标记-清除算法"></a>1）标记-清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="2）复制算法"><a href="#2）复制算法" class="headerlink" title="2）复制算法"></a>2）复制算法</h3><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<h3 id="3）标记-整理算法"><a href="#3）标记-整理算法" class="headerlink" title="3）标记-整理算法"></a>3）标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="4）分代收集算法"><a href="#4）分代收集算法" class="headerlink" title="4）分代收集算法"></a>4）分代收集算法</h3><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。<br>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。<br>垃圾收集器主要有 <strong>Serial收集器、Parallel收集器、Parallel Old 收集器、CMS收集器、G1收集器</strong> 等</p>
<h1 id="七）JAVA-四中引用类型"><a href="#七）JAVA-四中引用类型" class="headerlink" title="七）JAVA 四中引用类型"></a>七）JAVA 四中引用类型</h1><p>将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。<br>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：</p>
<ul>
<li><p>强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。 </p>
</li>
<li><p>软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）。软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 </p>
</li>
<li><p>弱引用：在GC时一定会被GC回收。弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。 </p>
</li>
<li><p>虚引用：由于虚引用只是用来得知对象是否被GC。虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。 </p>
</li>
</ul>
<h1 id="八）JVM线程与原生线程的关系"><a href="#八）JVM线程与原生线程的关系" class="headerlink" title="八）JVM线程与原生线程的关系"></a>八）JVM线程与原生线程的关系</h1><p>JVM允许一个程序使用多个并发线程，Hotspot JVM中Java的线程与原生操作系统的线程是直接映射关系。即当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。run() 返回时，被处理未捕获异常，原生线程将确认由于它的结束是否要终止 JVM 进程（比如这个线程是最后一个非守护线程）。当线程结束时，会释放原生线程和 Java 线程的所有资源。</p>
<h1 id="九）JVM性能调优"><a href="#九）JVM性能调优" class="headerlink" title="九）JVM性能调优"></a>九）JVM性能调优</h1><p>阅读：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483966&amp;idx=1&amp;sn=dfa3375d36aa2c0c25a775522e381e62&amp;chksm=ebf6da41dc815357e0d53c73865a23f41219e75bac5a4d510bfa31cc51594b59a20e2e4f6cb8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(四):jvm调优-命令篇</a><br>[2]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483986&amp;idx=1&amp;sn=a2d7c9f2e73dfcc938a3ec934b3ad3a4&amp;chksm=ebf6da2ddc81533beb5e6fb54c872b5f79524d0780c484718a57ca0712916cd67bda7dee4073&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(五):Java GC 分析</a><br>[3]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484007&amp;idx=1&amp;sn=e8d150bb760d0a92aad594152fc47a9d&amp;chksm=ebf6da18dc81530eedeaff89d746cf48e7b2bdec602239faaeb4e8e490e0a4387e2a8890c327&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(六):Java服务GC参数调优案例</a><br>[4]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484023&amp;idx=1&amp;sn=39be119fdf3132240adc84a85bf8a054&amp;chksm=ebf6da08dc81531e3719389555150f2d0237554b6b6c07a123efdea7c78c0ae2f064cc577bd4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(七):jvm调优-工具篇</a><br>[5]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484042&amp;idx=1&amp;sn=51d2ed451151be872b601007597dd47f&amp;chksm=ebf6daf5dc8153e3a7cb88ca97621cfae5aeaaeec0a1ff63e16278fbea6a43457e50a7fc9f0b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(九):如何优化Java GC「译」</a><br>[6]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484071&amp;idx=1&amp;sn=84604a51fd18b91f73c46507c182540a&amp;chksm=ebf6dad8dc8153cebb029372c0745a3c6570e527e1f95cee2fb9fb33c50d46c64f20722a3d96&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(十):教你如何成为Java的OOM Killer</a></p>
<h1 id="十）Java8中JVM内存的变化"><a href="#十）Java8中JVM内存的变化" class="headerlink" title="十）Java8中JVM内存的变化"></a>十）Java8中JVM内存的变化</h1><p><strong>完全移除了持久代，用MetaSpace来代替它</strong><br>阅读：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484074&amp;idx=1&amp;sn=826318867783afaf99f62b38b2f5c268&amp;chksm=ebf6dad5dc8153c32a6ce0201afe310b47135b07c8bb028a8fd9df7ecaf6e60950a7847c7df5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(十一):Java 8-从持久代到metaspace</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>类加载部分：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/43845064" target="_blank" rel="noopener">JVM系列(五) - JVM类加载机制详解</a></p>
<p>JVM内存结构部分：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483949&amp;idx=1&amp;sn=8b69d833bbc805e63d5b2fa7c73655f5&amp;chksm=ebf6da52dc815344add64af6fb78fee439c8c27b539b3c0e87d8f6861c8422144d516ae0a837&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(二):JVM内存结构</a><br>[2]<a href="https://www.cnblogs.com/cielosun/p/6622983.html#31-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc-program-counter" target="_blank" rel="noopener">Java基础：Java虚拟机(JVM)</a></p>
<p>垃圾回收部分：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483952&amp;idx=1&amp;sn=ea12792a9b7c67baddfaf425d8272d33&amp;chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器</a><br>[2]<a href="https://www.cnblogs.com/cielosun/p/6622983.html#31-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc-program-counter" target="_blank" rel="noopener">Java基础：Java虚拟机(JVM)</a><br>[3]<a href="https://www.jianshu.com/p/a4c07dcd92f9" target="_blank" rel="noopener">JAVA GC回收算法</a></p>
<p>JVM性能调优部分：<br>[1]<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483966&amp;idx=1&amp;sn=dfa3375d36aa2c0c25a775522e381e62&amp;chksm=ebf6da41dc815357e0d53c73865a23f41219e75bac5a4d510bfa31cc51594b59a20e2e4f6cb8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(四):jvm调优-命令篇</a></p>
<p>其他：<br>[1]<a href="https://zhuanlan.zhihu.com/p/34426768" target="_blank" rel="noopener">关于Jvm知识看这一篇就够了</a><br>[2]<a href="https://zhuanlan.zhihu.com/p/25511795" target="_blank" rel="noopener">jvm知识点总览</a><br>[3]<a href="https://zhuanlan.zhihu.com/p/54323768" target="_blank" rel="noopener">JVM（一）史上最佳入门指南</a><br>[4]<a href="https://segmentfault.com/a/1190000002579346#articleHeader1" target="_blank" rel="noopener">JVM 的 工作原理，层次结构 以及 GC工作原理</a><br>[5]<a href="https://www.jianshu.com/p/904b15a8281f" target="_blank" rel="noopener">学习JVM是如何从入门到放弃的？</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/07/04/JVM详解/" data-id="ck3lt36sd00025wub9xlasegt" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOElEQVR42u3a0W6DMAxGYd7/pdntpA16fhsqxTm5qiYK+Zjk2rGPA6/z1/r796vPV9+6v8P99a0lQ4aMZRnn7eLbqlHT13G5BxkyZGzAIKHwnnQFqF3P9yZDhgwZ5BoSpsn16XNlyJAhgwTcWnVZSyVlyJAhg6dxPAVMy90v1eIyZMhYkMGD5vc/v9LfkCFDxlKMM1y1ozfSwuRB9p8nypAhYzSDBzi+UZ66BQUqSS5lyJCxAeOp0Ye01EwP4NBxmwwZMoYyeChM07404eMv98PvhgwZMkYwSFhMD8LSwS9eDCd5ogwZMuYw7kNh7QSevywyHBYc5MmQIWMog2wlzTRrYxm1sY/g/yBDhoxlGbyI5SG41lroj33IkCFjKqPTDOBpXCdAoxaCDBkyNmDUDt3SAYvO8FkwZiFDhoxxDF5q8pqxcwzHhy2O2oZkyJCxIIMfsdVam+RArdMc/TBsIUOGjBGMNO17L/iSe6I8V4YMGUMZj3UYSslfp4SWIUPGbox+KftGyfrYyIUMGTIWZ/CEj7ch01EznqRe7lCGDBkbMDrlK2lGpiE7PpKTIUPGZgwSIkm4JKlnp4SWIUPGDowzXJ1v1WYkgvpbhgwZQxlpmCOFa+0OJHCnT5QhQ8YkBg+yPAVMi960IRH/esiQIWMEIw18/HAtHado1eIyZMiQUUoZa9fzdoIMGTJkpGMQfTDHxzMjMmTIWJzRSfjSJLLWDJAhQ8bOjLR0TDfHt5sOqMmQIWMDxg887omHejEFjQAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/知识/">知识</a></div><div class="post-nav"><a class="pre" href="/2019/07/10/LeetCode-146-LRU缓存机制/">LeetCode-146.LRU缓存机制</a><a class="next" href="/2019/07/03/Java8新的时间和日期API/">Java8新的时间和日期API</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://dcrunnn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/分布式ETL工具/" style="font-size: 15px;">分布式ETL工具</a> <a href="/tags/分布式数据采集工具/" style="font-size: 15px;">分布式数据采集工具</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/分布式消息队列/" style="font-size: 15px;">分布式消息队列</a> <a href="/tags/分布式计算框架/" style="font-size: 15px;">分布式计算框架</a> <a href="/tags/分布式资源管理框架/" style="font-size: 15px;">分布式资源管理框架</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-面向对象设计原则/">设计模式理论篇 | 面向对象设计原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-设计模式综述/">设计模式理论篇 | 设计模式综述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-责任链模式/">设计模式理论篇 | 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-装饰者模式/">设计模式理论篇 | 装饰者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式消息队列Kafka/">大数据理论篇 | 分布式消息队列Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式数据采集工具Flume/">大数据理论篇 | 分布式数据采集工具Flume</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式ETL工具Sqoop/">大数据理论篇 | 分布式ETL工具Sqoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（Spark篇）/">大数据理论篇 | 分布式计算框架（Spark篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（MapReduce篇）/">大数据理论篇 | 分布式计算框架（MapReduce篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/27/设计模式理论篇-桥接模式/">设计模式理论篇 | 桥接模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>