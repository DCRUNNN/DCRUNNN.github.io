<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>Java8新的时间和日期API | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java8新的时间和日期API</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java8新的时间和日期API</h1><div class="post-meta">Jul 3, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#旧的缺陷"><span class="toc-text">旧的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8日期-时间类"><span class="toc-text">Java 8日期/时间类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#综述"><span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDate和LocalTime"><span class="toc-text">LocalDate和LocalTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDateTime"><span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instant"><span class="toc-text">Instant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duration"><span class="toc-text">Duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Period"><span class="toc-text">Period</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作日期"><span class="toc-text">操作日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#增加和减少日期"><span class="toc-text">增加和减少日期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#格式化日期"><span class="toc-text">格式化日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时区"><span class="toc-text">时区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他历法"><span class="toc-text">其他历法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-Snippets"><span class="toc-text">Code Snippets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与旧代码交互"><span class="toc-text">与旧代码交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-More"><span class="toc-text">Read More</span></a></li></ol></div></div><div class="post-content"><h2 id="旧的缺陷"><a href="#旧的缺陷" class="headerlink" title="旧的缺陷"></a>旧的缺陷</h2><p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p>
<ol>
<li>Java的java.util.Date和java.util.Calendar类易用性差，不支持时区，而且他们都不是线程安全的；</li>
<li>用于格式化日期的类DateFormat被放在java.text包中，它是一个抽象类，所以我们需要实例化一个SimpleDateFormat对象来处理日期格式化，并且DateFormat也是非线程安全，这意味着如果你在多线程程序中调用同一个DateFormat对象，会得到意想不到的结果。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从Calendar中获取的月份需要加一才能表示当前月份。</li>
</ol>
<p>由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是JSR-310规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p>
<h2 id="Java-8日期-时间类"><a href="#Java-8日期-时间类" class="headerlink" title="Java 8日期/时间类"></a>Java 8日期/时间类</h2><p>Java 8的日期和时间类包含LocalDate、LocalTime、Instant、Duration以及Period，这些类都包含在java.time包中，下面我们看看这些类的用法。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>新的API：java.time，由5个包组成：</p>
<ul>
<li>java.time – 包含值对象的基础包</li>
<li>java.time.chrono – 提供对不同的日历系统的访问</li>
<li>java.time.format – 格式化和解析时间和日期</li>
<li>java.time.temporal – 包括底层框架和扩展特性</li>
<li>java.time.zone – 包含时区支持的类<br>大多数开发者只会用到基础和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概，将只会用到其中的三分之一。</li>
</ul>
<h3 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h3><p>LocalDate类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过LocalDate的静态方法of()创建一个实例，LocalDate也包含一些方法用来获取年份，月份，天，星期几等：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">3</span>);     <span class="comment">// 初始化一个日期：2019-07-03</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();                     <span class="comment">// 年份：2019</span></span><br><span class="line">Month month = localDate.getMonth();                 <span class="comment">// 月份：JULY</span></span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();         <span class="comment">// 月份中的第几天：3</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();     <span class="comment">// 一周的第几天：WEDNESDAY</span></span><br><span class="line"><span class="keyword">int</span> length = localDate.lengthOfMonth();             <span class="comment">// 月份的天数：31</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = localDate.isLeapYear();          <span class="comment">// 是否为闰年：false</span></span><br></pre></td></tr></table></figure></p>
<p>也可以调用静态方法now()来获取当前日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();  <span class="comment">// 2019-07-03</span></span><br></pre></td></tr></table></figure></p>
<p>LocalTime和LocalDate类似，他们之间的区别在于LocalDate不包含具体时间，而LocalTime包含具体时间，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">21</span>, <span class="number">48</span>, <span class="number">26</span>);     <span class="comment">// 初始化一个时间：21:48:26</span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();                     <span class="comment">// 时：21</span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();                 <span class="comment">// 分：48</span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();                 <span class="comment">// 秒：26</span></span><br></pre></td></tr></table></figure></p>
<p>同样可以调用静态方法now()来获取当前时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now = LocalTime.now()  <span class="comment">// 21:48:21.487</span></span><br></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime类是LocalDate和LocalTime的结合体，可以通过of()方法直接创建，也可以调用LocalDate的atTime()方法或LocalTime的atDate()方法将LocalDate或LocalTime合并成一个LocalDateTime：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2019</span>, Month.JULY, <span class="number">3</span>, <span class="number">21</span>, <span class="number">48</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2019</span>, Month.JULY, <span class="number">3</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">21</span>, <span class="number">48</span>, <span class="number">26</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br></pre></td></tr></table></figure></p>
<p>LocalDateTime也提供用于向LocalDate和LocalTime的转化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt1 = LocalDateTime.now(); <span class="comment">// 2019-07-03T21:54:11.707</span></span><br><span class="line">LocalDate date = ldt1.toLocalDate(); <span class="comment">// 2019-07-03</span></span><br><span class="line">LocalTime time = ldt1.toLocalTime(); <span class="comment">// 21:54:11.707</span></span><br></pre></td></tr></table></figure></p>
<p>LocalDateTime的其他方法跟LocalDate和LocalTime相似。这种相似的方法模式非常有利于API的学习。下面总结了用到的方法前缀：</p>
<ul>
<li>of： 静态工厂方法，从组成部分中创建实例</li>
<li>from： 静态工厂方法，尝试从相似对象中提取实例。from()方法没有of()方法类型安全</li>
<li>now： 静态工厂方法，用当前时间创建实例</li>
<li>parse： 静态工厂方法，总字符串解析得到对象实例</li>
<li>get： 获取时间日期对象的部分状态</li>
<li>is： 检查关于时间日期对象的描述是否正确</li>
<li>with： 返回一个部分状态改变了的时间日期对象拷贝</li>
<li>plus： 返回一个时间增加了的、时间日期对象拷贝</li>
<li>minus： 返回一个时间减少了的、时间日期对象拷贝</li>
<li>to： 把当前时间日期对象转换成另外一个，可能会损失部分状态</li>
<li>at： 用当前时间日期对象组合另外一个，创建一个更大或更复杂的时间日期对象</li>
<li>format： 提供格式化时间日期对象的能力</li>
</ul>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>Instant用于表示一个时间戳，它与我们常使用的System.currentTimeMillis()有些类似，不过Instant可以精确到纳秒（Nano-Second），System.currentTimeMillis()方法只精确到毫秒（Milli-Second）。如果查看Instant源码，发现它的内部使用了两个常量，seconds表示从1970-01-01 00:00:00开始到现在的秒数，nanos表示纳秒部分（nanos的值不会超过999,999,999）。<br>Instant典型的用法是，当你需要记录事件的发生时间，而不需要记录任何有关时区信息时，存储和比较时间戳。<br>Instant除了使用now()方法创建外，还可以通过ofEpochSecond方法创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.now(); <span class="comment">// 2019-07-03T13:56:36.792Z</span></span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>); <span class="comment">// 1970-01-01T00:02:00.000100Z</span></span><br></pre></td></tr></table></figure></p>
<p>ofEpochSecond()方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻。</p>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>Duration的内部实现与Instant类似，也是包含两部分：seconds表示秒，nanos表示纳秒。两者的区别是Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段，所以Duration类中不包含now()静态方法。可以通过Duration.between()方法创建Duration对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of(<span class="number">2019</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);    <span class="comment">// 2019-01-01 10:07:00</span></span><br><span class="line">LocalDateTime to = LocalDateTime.of(<span class="number">2019</span>, Month.JULY, <span class="number">3</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">0</span>);     <span class="comment">// 2019-07-03 21:59:00</span></span><br><span class="line">Duration duration = Duration.between(from, to);     <span class="comment">// 表示从 2019-01-01 10:07:00 到 2019-07-03 21:59:00 这段时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br></pre></td></tr></table></figure></p>
<p>Duration对象还可以通过of()方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Duration duration1 = Duration.of(<span class="number">5</span>, ChronoUnit.DAYS);       <span class="comment">// 5天</span></span><br><span class="line">Duration duration2 = Duration.of(<span class="number">1000</span>, ChronoUnit.MILLIS);  <span class="comment">// 1000毫秒</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>Period在概念上和Duration类似，区别在于Period是以年月日来衡量一个时间段，比如2年3个月6天：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>Period对象也可以通过between()方法创建，值得注意的是，由于Period是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2019-01-01 到 2019-07-03 这段时间</span></span><br><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>), LocalDate.of(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="操作日期"><a href="#操作日期" class="headerlink" title="操作日期"></a>操作日期</h2><h3 id="增加和减少日期"><a href="#增加和减少日期" class="headerlink" title="增加和减少日期"></a>增加和减少日期</h3><p>Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">3</span>);          <span class="comment">// 2019-07-03</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2018</span>);              <span class="comment">// 修改为 2018-07-03</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2019-02-03</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2019-07-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2020-07-03</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2019-05-03</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2019-07-08</span></span><br></pre></td></tr></table></figure></p>
<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用with()方法的另一个重载方法，它接收一个TemporalAdjuster参数，可以使我们更加灵活的调整日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date7 = date.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(TemporalAdjusters.lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure></p>
<p>TemporalAdjusters类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：<br>| 方法名 | 描述 |<br>| :——: | :——: |<br>| dayOfWeekInMonth | 返回同一个月中每周的第几天 |<br>| firstDayOfMonth | 返回当月的第一天 |<br>| firstDayOfNextMonth | 返回下月的第一天 |<br>| firstDayOfNextYear | 返回下一年的第一天 |<br>| firstDayOfYear | 返回本年的第一天 |<br>| firstInMonth | 返回同一个月中第一个星期几 |<br>| lastDayOfMonth | 返回当月的最后一天 |<br>| lastDayOfNextMonth | 返回下月的最后一天 |<br>| lastDayOfNextYear | 返回下一年的最后一天 |<br>| lastDayOfYear | 返回本年的最后一天 |<br>| lastInMonth | 返回同一个月中最后一个星期几 |<br>| next / previous | 返回后一个/前一个给定的星期几 |<br>| nextOrSame / previousOrSame | 返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回 |</p>
<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的TemporalAdjuster接口的实现，TemporalAdjuster也是一个函数式接口，所以我们可以使用Lambda表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">date.with(temporal -&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下，每次增加一天</span></span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期五，增加三天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期六，增加两天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><p>新的日期API中提供了一个DateTimeFormatter类用于处理日期格式化操作，它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串，该方法接收一个DateTimeFormatter类型参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now(); <span class="comment">// 2019-07-03T22:19:47.703</span></span><br><span class="line">String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">// 20190703</span></span><br><span class="line">String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    <span class="comment">// 2019-07-03</span></span><br><span class="line">String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    <span class="comment">// 22:19:47.703</span></span><br><span class="line">String strDate4 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME); <span class="comment">// 2019-07-03T22:19:47.703</span></span><br><span class="line">String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));   <span class="comment">// 2019-07-03</span></span><br><span class="line">String strDate6 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"今天是：yyyy年 MM月 dd日 E"</span>, Locale.CHINESE)); <span class="comment">// 今天是：2019年 07月 03日 星期三</span></span><br></pre></td></tr></table></figure></p>
<p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String strDate7 = <span class="string">"2019-07-03"</span>;</span><br><span class="line">String strDate8 = <span class="string">"2019-07-03 22:19:47"</span>;</span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.parse(strDate7, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.parse(strDate8, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>Java 8中的时区操作被很大程度上简化了，新的时区类java.time.ZoneId是原有的java.util.TimeZone类的替代品。ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure></p>
<p>of()方法接收一个“区域/城市”的字符串作为参数，你可以通过getAvailableZoneIds()方法获取所有合法的“区域/城市”字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure></p>
<p>对于老的时区类TimeZone，Java 8也提供了转化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure></p>
<p>有了ZoneId，我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.of(<span class="string">"Asia/Shanghai"</span>)); <span class="comment">// 2019-07-03T22:31:04.952+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure></p>
<p>ZonedDateTime对象由两部分构成，LocalDateTime和ZoneId，其中2019-07-03T22:31:04.952部分为LocalDateTime，+08:00[Asia/Shanghai]部分为ZoneId。</p>
<p>另一种表示时区的方式是使用ZoneOffset，它是以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure></p>
<h2 id="其他历法"><a href="#其他历法" class="headerlink" title="其他历法"></a>其他历法</h2><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>
<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是</p>
<ul>
<li>ThaiBuddhistDate：泰国佛教历</li>
<li>MinguoDate：中华民国历</li>
<li>JapaneseDate：日本历</li>
<li>HijrahDate：伊斯兰历<br>每个日期类都继承ChronoLocalDate类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。<br>这些不同的历法也可以用于向公历转换：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">JapaneseDate jpDate = JapaneseDate.from(date);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于它们都继承ChronoLocalDate类，所以在不知道具体历法情况下，可以通过ChronoLocalDate类操作日期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);</span><br><span class="line">ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();</span><br></pre></td></tr></table></figure></p>
<p>我们在开发过程中应该尽量避免使用ChronoLocalDate，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>
<p>在实际开发过程中建议使用LocalDate，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用ChronoLocalDate类。</p>
<h2 id="Code-Snippets"><a href="#Code-Snippets" class="headerlink" title="Code Snippets"></a>Code Snippets</h2><ol>
<li><p>获取当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">Date now = <span class="keyword">new</span> Date();  <span class="comment">// Wed Jul 03 22:45:55 CST 2019</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">ZonedDateTime now = ZonedDateTime.now(); <span class="comment">// 2019-07-03T22:45:55.434+08:00[Asia/Shanghai]</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now(); <span class="comment">// 2019-07-03T22:45:55.453</span></span><br><span class="line">LocalDate now = LocalDate.now(); <span class="comment">// 2019-07-03</span></span><br><span class="line">LocalTime now = LocalTime.now(); <span class="comment">// 22:45:55.453</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>表示特定时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">Date birthDay = <span class="keyword">new</span> GregorianCalendar(<span class="number">1990</span>, Calendar.DECEMBER, <span class="number">15</span>).getTime(); <span class="comment">// Sat Dec 15 00:00:00 CST 1990</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalDate birthDay = LocalDate.of(<span class="number">1990</span>, Month.DECEMBER, <span class="number">15</span>); <span class="comment">// 1990-12-15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取时间中特定部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line"><span class="keyword">int</span> month = <span class="keyword">new</span> GregorianCalendar().get(Calendar.MONTH); <span class="comment">// 6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">Month month = LocalDateTime.now().getMonth(); <span class="comment">// JULY</span></span><br><span class="line"><span class="keyword">int</span> valueOfMonth = LocalDateTime.now().getMonth().getValue(); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加减时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">GregorianCalendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">calendar.add(Calendar.HOUR_OF_DAY, -<span class="number">5</span>);</span><br><span class="line">Date fiveHoursBefore = calendar.getTime();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalDateTime fiveHoursBefore = LocalDateTime.now().minusHours(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整特定部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">GregorianCalendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">calendar.set(Calendar.MONTH, Calendar.JUNE);</span><br><span class="line">Date inJune = calendar.getTime();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalDateTime inJune = LocalDateTime.now().withMonth(Month.JUNE.getValue());</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取<br>截断重置小于指定字段的所有时间字段。在下面的示例中，分钟和下面的所有内容都将设置为零：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">Calendar now = Calendar.getInstance();</span><br><span class="line">now.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">now.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">now.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">Date truncated = now.getTime();  <span class="comment">// Wed Jul 03 22:00:00 CST 2019</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalTime truncated = LocalTime.now().truncatedTo(ChronoUnit.HOURS); <span class="comment">// 22:00</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>时区转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">GregorianCalendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">calendar.setTimeZone(TimeZone.getTimeZone(<span class="string">"CET"</span>));</span><br><span class="line">Date centralEastern = calendar.getTime(); <span class="comment">// Wed Jul 03 22:56:29 CST 2019</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">ZonedDateTime centralEastern = LocalDateTime.now().atZone(ZoneId.of(<span class="string">"CET"</span>)); <span class="comment">// 2019-07-03T22:56:30.005+02:00[CET]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获得两个时间点之间的时间跨度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">GregorianCalendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">1</span>);</span><br><span class="line">Date hourLater = calendar.getTime();</span><br><span class="line"><span class="keyword">long</span> elapsed = hourLater.getTime() - now.getTime();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">LocalDateTime hourLater = LocalDateTime.now().plusHours(<span class="number">1</span>);</span><br><span class="line">Duration span = Duration.between(now, hourLater);  <span class="comment">// span.toMillis()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>时间格式化及解析<br>DateTimeFormatter是旧的SimpleDateFormat的替代品，它是线程安全的并提供其他功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line">String formattedDate = dateFormat.format(now); <span class="comment">// 2019-07-03</span></span><br><span class="line">Date parsedDate = dateFormat.parse(formattedDate); <span class="comment">// Wed Jul 03 00:00:00 CST 2019</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">String formattedDate = now.format(formatter); <span class="comment">// 2019-07-03</span></span><br><span class="line"><span class="comment">// or String formattedDate = now.format(DateTimeFormatter.ISO_LOCAL_DATE) </span></span><br><span class="line">LocalDate parsedDate = LocalDate.parse(formattedDate, formatter); <span class="comment">// 2019-07-03</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个月的天数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">Calendar calendar = <span class="keyword">new</span> GregorianCalendar(<span class="number">1990</span>, Calendar.FEBRUARY, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// New</span></span><br><span class="line"><span class="keyword">int</span> daysInMonth = YearMonth.of(<span class="number">1990</span>, <span class="number">2</span>).lengthOfMonth();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="与旧代码交互"><a href="#与旧代码交互" class="headerlink" title="与旧代码交互"></a>与旧代码交互</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Instant instantFromCalendar = GregorianCalendar.getInstance().toInstant();</span><br><span class="line"></span><br><span class="line">ZonedDateTime zonedDateTimeFromCalendar = <span class="keyword">new</span> GregorianCalendar().toZonedDateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant转Date</span></span><br><span class="line">Date dateFromInstant = Date.from(Instant.now());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Date转LocalDate</span></span><br><span class="line">LocalDate localDate = <span class="keyword">new</span> Date().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDate转Date</span></span><br><span class="line">Date date = Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line">GregorianCalendar calendarFromZonedDateTime = GregorianCalendar.from(ZonedDateTime.now());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Date转Instant</span></span><br><span class="line">Instant instantFromDate = <span class="keyword">new</span> Date().toInstant();</span><br><span class="line"></span><br><span class="line">ZoneId zoneIdFromTimeZone = TimeZone.getTimeZone(<span class="string">"PST"</span>).toZoneId();</span><br></pre></td></tr></table></figure>
<h2 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a>Read More</h2><p>[1]<a href="https://blog.csdn.net/hqfok/article/details/53100517" target="_blank" rel="noopener">JAVA 8：健壮、易用的时间/日期API</a><br>[2]<a href="https://leongfeng.github.io/2016/12/07/java8-time-api-learning/" target="_blank" rel="noopener">Java 8 学习之——时间日期API</a><br>[3]<a href="https://lw900925.github.io/java/java8-newtime-api.html" target="_blank" rel="noopener">Java 8新特性（四）：新的时间和日期API</a><br>[4]<a href="https://www.baeldung.com/java-datetimeformatter" target="_blank" rel="noopener">Guide to DateTimeFormatter</a><br>[5]<a href="https://www.baeldung.com/joda-time" target="_blank" rel="noopener">Introduction to Joda-Time</a><br>[6]<a href="https://www.baeldung.com/current-date-time-and-timestamp-in-java-8" target="_blank" rel="noopener">Get the Current Date, Time and Timestamp in Java 8</a><br><strong>[7]<a href="https://www.baeldung.com/java-8-date-time-intro" target="_blank" rel="noopener">Introduction to the Java 8 Date/Time API</a></strong><br>[8]<a href="https://www.baeldung.com/migrating-to-java-8-date-time-api" target="_blank" rel="noopener">Migrating to the New Java 8 Date Time API</a><br>[9]<a href="https://www.jianshu.com/p/b4629857fc6f" target="_blank" rel="noopener">LocalDate、LocalDateTime与timestamp、Date的转换</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2019/07/03/Java8新的时间和日期API/" data-id="ck3n6lc7900055oubcjmingo8" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACv0lEQVR42u3aS46DQAwFwNz/0hlptlHg+dMzLIpVRAJ0Ealt2X694uP9e3ye+Tyf/Ob62uurXicOPDw8vNbSvx2ft84/X59J1pDc7dtVeHh4eKd518Ggeuvr30+ekq8ZDw8P7wm8HmCSxCdBCA8PD+/JvByWbOV5gPmHuIeHh4cX8HrlgLygcH1V9dsjtRY8PDy8mFdtgD3h88H+Hh4eHt6gq55vu8mIQK+5NVktHh4e3glePj51/ZjJsFTCyMu7hckvPDw8vDGvNwK1FVp64OiF4uHh4a3y8u11C5MXeRcScTw8PLwDvHnbqVp4rTbJkiLIzd+Dh4eHt8rrJa+9bb06ipoPK0RxDw8PD2+JVx0UmA+55svNy8flIQM8PDy8Aa/3+GrpIU+1e423ryEHDw8P7wAvSXO3ANVQ0QtOeHh4eH/Py9v51bGtvDBRLRk3a9V4eHh4S7zeyFSeIlcDQy9U3MQ9PDw8vFVeXtjNW1bVJeavKf8D8PDw8HZ51U32+qbvwTFvpOHh4eGd5lXHpHqlimrZN7/bDR4PDw/vD3n5mWry3WtiLVSm8fDw8JZ41c03L0MkS5+/pq3QgoeHh5fzkgt6razqG81XUij+4uHh4R3m5cudb/d5vKom+jdlXDw8PLwxb54uV5PpSSOtV0DBw8PDO8GrNuyTMNBroW0VL5r9Nzw8PLyY1wsAvWS3OjqQj2fdjF7h4eHhHeBVH3O9HffKCr1BrvJ8BB4eHt6A9y4e+aupJsqTcu3X9B0PDw/vAK+37fZGCqrhpJqCV8cL8PDw8Ca8fJtOXkGv8JoHoYXRATw8PLwl3qRIkS96MmrQfK14eHh4j+Hl31Yrq/NRg4XAgIeHh7fEK6ez8UKrwwd5yRgPDw/vHC9vR/W27F6QWGh64eHh4R3gzRtg+Zadv77e4EITiYeHh5eu6gfXjoi9mPkS+gAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/Java8/">Java8</a></div><div class="post-nav"><a class="pre" href="/2019/07/04/JVM详解/">JVM学习之路</a><a class="next" href="/2019/06/01/Enum的使用/">Enum的使用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://dcrunnn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/分布式数据采集工具/" style="font-size: 15px;">分布式数据采集工具</a> <a href="/tags/分布式ETL工具/" style="font-size: 15px;">分布式ETL工具</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/分布式计算框架/" style="font-size: 15px;">分布式计算框架</a> <a href="/tags/分布式消息队列/" style="font-size: 15px;">分布式消息队列</a> <a href="/tags/分布式资源管理框架/" style="font-size: 15px;">分布式资源管理框架</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-面向对象设计原则/">设计模式理论篇 | 面向对象设计原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-设计模式综述/">设计模式理论篇 | 设计模式综述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-责任链模式/">设计模式理论篇 | 责任链模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/设计模式理论篇-装饰者模式/">设计模式理论篇 | 装饰者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式消息队列Kafka/">大数据理论篇 | 分布式消息队列Kafka</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式数据采集工具Flume/">大数据理论篇 | 分布式数据采集工具Flume</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/大数据理论篇-分布式ETL工具Sqoop/">大数据理论篇 | 分布式ETL工具Sqoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（Spark篇）/">大数据理论篇 | 分布式计算框架（Spark篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/大数据理论篇-分布式计算框架（MapReduce篇）/">大数据理论篇 | 分布式计算框架（MapReduce篇）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/27/设计模式理论篇-桥接模式/">设计模式理论篇 | 桥接模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>