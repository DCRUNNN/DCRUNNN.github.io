<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="DC's Blog"><title>高并发处理 | 限流 | Blog of DC</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">高并发处理 | 限流</h1><a id="logo" href="/.">Blog of DC</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">高并发处理 | 限流</h1><div class="post-meta">Jun 17, 2020<span> | </span><span class="category"><a href="/categories/高并发/">高并发</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、高并发场景做的系统优化"><span class="toc-text">一、高并发场景做的系统优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、限流的概念"><span class="toc-text">二、限流的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、限流算法"><span class="toc-text">三、限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-时间窗口算法"><span class="toc-text">3.1 时间窗口算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-漏桶算法"><span class="toc-text">3.2 漏桶算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-令牌桶算法"><span class="toc-text">3.3 令牌桶算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-计数器"><span class="toc-text">3.4 计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、容器限流"><span class="toc-text">三、容器限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Tomcat限流"><span class="toc-text">3.1 Tomcat限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Nginx限流"><span class="toc-text">3.2 Nginx限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-说明"><span class="toc-text">3.3 说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、服务端限流"><span class="toc-text">四、服务端限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-限制某个接口的总并发数-请求数"><span class="toc-text">4.1 限制某个接口的总并发数/请求数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-限流某个接口的时间窗请求数"><span class="toc-text">4.2 限流某个接口的时间窗请求数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-平滑限流某个接口的请求数"><span class="toc-text">4.3 平滑限流某个接口的请求数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-常规速率-SmoothBursty（平滑输出）"><span class="toc-text">4.3.1 常规速率 SmoothBursty（平滑输出）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-SmoothBursty-突发流量"><span class="toc-text">4.3.2 SmoothBursty 突发流量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-SmoothWarmingUp-带缓冲的流量输出"><span class="toc-text">4.3.3 SmoothWarmingUp 带缓冲的流量输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Alibaba-Sentinel"><span class="toc-text">4.4 Alibaba Sentinel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、分布式限流"><span class="toc-text">五、分布式限流</span></a></li></ol></div></div><div class="post-content"><h2 id="一、高并发场景做的系统优化"><a href="#一、高并发场景做的系统优化" class="headerlink" title="一、高并发场景做的系统优化"></a>一、高并发场景做的系统优化</h2><ol>
<li><strong>限流</strong>：对入口流量做控制，对下游请求流量做自适应限流，根据接口响应时间动态调整流量</li>
<li><strong>消息队列</strong>：将请求写到mq里，后面系统逐条消费消息</li>
<li><strong>缓存</strong>：对于读多写少的场景，用缓存来提升高并发能力</li>
<li>负载均衡：</li>
<li>路由：若请求都依赖下游第三方的服务，可以将多家下游服务供应商做个动态路由表，将请求优先路由给接口成功率高、耗时低的服务供应商</li>
<li>备份：基本是所有分布式组件都会做的，拆分节点，做多机部署，例如：Redis做三主三备(集群)、MySQL分库分表、MQ 与 Redis 互为备份等等；</li>
<li>静态化数据：静态文件（如图片等）上传cdn，cdn节点缓存静态文件，减少服务器压力</li>
<li><strong>降级</strong>：当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开。使用降级手段保障系统核心功能可用，或让模块达到最小可用。</li>
<li>日志：完整的监控和链路日志，一是方便排查问题，二是可用来做任务重试、任务回滚、数据恢复、状态持久化等</li>
</ol>
<h2 id="二、限流的概念"><a href="#二、限流的概念" class="headerlink" title="二、限流的概念"></a>二、限流的概念</h2><ol>
<li>通过对并发访问、并发请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以：<br> a. 拒绝服务（定向到错误页或告知资源没有了）<br> b. 排队或等待（比如秒杀、评论、下单）、<br> c. 降级（返回兜底数据或默认数据，如商品详情页库存默认有货）</li>
<li>常见限流手段：<br> a. 限制总并发数<br> b. 限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）<br> c. 限制时间窗口内的平均速率（如Guava的RateLimiter、Nginx的limit_req模块，限制每秒的平均速率）<br> d. 限流某个接口的总并发/请求数<br> d. 限制远程接口调用速率、限制MQ的消费速率。<br> e. 根据网络连接数、网络流量、CPU或内存负载等来限流<br> f. 限制总资源数：可以使用池化技术来限制总资源数（连接池、线程池等），比如数据库连接池、线程池，Mysql（如max_connections）、缓存Redis（如tcp-backlog）</li>
<li>限流的分类<br> a. 合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；<br> b. 容器限流：比如 Tomcat、Nginx等限流手段，其中Tomcat可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；<br> c. 服务端限流（应用级限流）：比如我们在服务器端通过限流算法实现限流<br> d. 分布式限流</li>
</ol>
<h2 id="三、限流算法"><a href="#三、限流算法" class="headerlink" title="三、限流算法"></a>三、限流算法</h2><h3 id="3-1-时间窗口算法"><a href="#3-1-时间窗口算法" class="headerlink" title="3.1 时间窗口算法"></a>3.1 时间窗口算法</h3><ol>
<li>以当前时间为截止时间，往前取一定的时间，比如往前取60s的时间，限制在这60s之内运行最大的访问数为100，此时算法的执行逻辑为，先清除60s之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端</li>
<li>可以借助 Redis 的有序集合 ZSet 来实现时间窗口算法限流，实现的过程是先使用 ZSet 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录<br> a. 缺点1：使用 ZSet 存储有每次的访问记录，如果数据量比较大时会占用大量的空间，比如 60s 允许 100W 访问时；<br> b. 缺点2：非原子操作，先判断后增加，中间空隙可穿插其他业务逻辑的执行，最终导致结果不准确</li>
</ol>
<h3 id="3-2-漏桶算法"><a href="#3-2-漏桶算法" class="headerlink" title="3.2 漏桶算法"></a>3.2 漏桶算法</h3><ol>
<li>滑动时间算法有一个问题就是在一定范围内，比如60s内只能有10个请求，当第一秒时就到达了10个请求，那么剩下的 59s 只能把所有的请求都给拒绝掉，而漏桶算法可以解决这个问题。</li>
<li>理解漏桶：无论上面的水流倒入漏斗有多大，也就是无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当上面的水流速度小于下面流出的速度的话，漏斗永远不会被装满，并且可以一直流出。</li>
<li>解释：<br> a. 一个固定容量的漏桶，按照常量固定速率流出水滴；<br> b. 如果桶是空的，则不需流出水滴；<br> c. 可以以任意速率流入水滴到漏桶；<br> d. 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li>
<li>实现：先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法</li>
<li>Nginx 的控制速率其实使用的就是漏桶算法</li>
<li>借助Redis也可以实现漏桶算法，可以使用Redis 4.0版本中提供的Redis-Cell模块中的cl.throttle指令，该模块使用的是漏斗算法，并且提供了原子的限流指令，而且依靠Redis这个天生的分布式程序就可以实现比较完美的限流了<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中 15 为漏斗的容量，30 / 60s 为漏斗的速率。</span></span><br><span class="line">&gt; cl.throttle mylimit <span class="number">15</span> <span class="number">30</span> <span class="number">60</span></span><br><span class="line">1）（integer）0 # 0 表示获取成功，1 表示拒绝</span><br><span class="line">2）（integer）15 # 漏斗容量</span><br><span class="line">3）（integer）14 # 漏斗剩余容量</span><br><span class="line">4）（integer）-1 # 被拒绝之后，多长时间之后再试（单位：秒）-1 表示无需重试</span><br><span class="line">5）（integer）2 # 多久之后漏斗完全空出来</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-令牌桶算法"><a href="#3-3-令牌桶算法" class="headerlink" title="3.3 令牌桶算法"></a>3.3 令牌桶算法</h3><ol>
<li>一个存放固定容量令牌的桶，有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行</li>
<li>令牌桶的方法可以根据系统负载，实时调节系统的处理能力，能够允许一定量级的瞬时高峰流量的快速消化，即请求的速率可以突发</li>
<li>Guava包的RateLimiter提供了令牌桶算法的支持（Guava的RateLimiter是程序级别的单机限流方案，上面的Redis-Cell提供的漏桶算法是分布式的限流方案）</li>
</ol>
<h3 id="3-4-计数器"><a href="#3-4-计数器" class="headerlink" title="3.4 计数器"></a>3.4 计数器</h3><ol>
<li>粗暴的限制限制总并发数，看单位时间内，所接受的QPS的请求有多少，如果超过阈值，则直接拒绝服务。</li>
<li>主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；只要全局总请求数或者一定时间段的总请求数设定的阀值则进行限流</li>
<li>可以用缓存（Guava Cache或者Caffeine Cache） + AtomicLong来实现</li>
</ol>
<h2 id="三、容器限流"><a href="#三、容器限流" class="headerlink" title="三、容器限流"></a>三、容器限流</h2><p>常见思路：</p>
<ol>
<li>限流总并发/连接/请求数</li>
<li>限流总资源数</li>
<li>控制速率</li>
</ol>
<h3 id="3-1-Tomcat限流"><a href="#3-1-Tomcat限流" class="headerlink" title="3.1 Tomcat限流"></a>3.1 Tomcat限流</h3><ol>
<li>在conf/server.xml中或者在application.yml中可以配置maxConnections、maxThreads、acceptCount<br> a. maxConnections：这个参数是指在同一时间，tomcat能够接受的最大连接数（瞬时最大连接数）。对于Java的阻塞式BIO，默认值是maxthreads的值；如果在BIO模式使用定制的Executor执行器，默认值将是执行器中maxthreads的值。对于Java 新的NIO模式，maxConnections 默认值是10000。<br> b. maxThreads：Tomcat的最大线程数，每一次HTTP请求到达Web服务，Tomcat都会创建一个线程来处理该请求，那么最大线程数决定了Web服务容器可以同时处理多少个请求，当请求的并发大于此值（maxThreads）时，请求就会排队执行，从而限流<br> c. acceptCount：最大等待数，当所有的请求处理线程都在使用时，所能接收的连接请求的队列的最大长度。当队列已满时，任何的连接请求都将被拒绝</li>
<li>对于maxThreads而言，操作系统对于进程中的线程数有一定的限制，Windows每个进程中的线程数上限2000，Linux 每个进程中的线程数不允许超过1000</li>
</ol>
<h3 id="3-2-Nginx限流"><a href="#3-2-Nginx限流" class="headerlink" title="3.2 Nginx限流"></a>3.2 Nginx限流</h3><ol>
<li>Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数</li>
<li><p>控制速率：使用 limit_req_zone 用来限制单位时间内的请求数，即速率限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制每个IP访问的速度为 2r/s，</span></span><br><span class="line"><span class="comment">// Nginx的限流统计是基于毫秒的，设置的速度是2r/s，即500ms内单个IP只允许通过1个请求，从501ms开始才允许通过第2个请求。</span></span><br><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:<span class="number">10</span>m rate=<span class="number">2</span>r/s;</span><br><span class="line">server &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>速率限制升级版：上面的速率控制虽然很精准但是应用于真实环境过于苛刻了，真实情况下我们应该控制一个IP单位总时间内的总访问次数，而不是像上面那样精确到毫秒，我们可以使用 burst 关键字开启此设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:<span class="number">10</span>m rate=<span class="number">2</span>r/s;</span><br><span class="line">server &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit burst=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制并发连接数：利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接</span></span><br><span class="line"><span class="comment">// limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个</span></span><br><span class="line"><span class="comment">// 只有当request header被后端处理后，这个连接才进行计数</span></span><br><span class="line">limit_conn_zone $binary_remote_addr zone=perip:<span class="number">10</span>m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:<span class="number">10</span>m;</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_conn perip <span class="number">10</span>;</span><br><span class="line">    limit_conn perserver <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-说明"><a href="#3-3-说明" class="headerlink" title="3.3 说明"></a>3.3 说明</h3><ol>
<li>在限制总并发/连接/请求数的场景中，数据库Mysql（如max_connections）、缓存Redis（如tcp-backlog）等，也有类似的限制连接数的配置。</li>
</ol>
<h2 id="四、服务端限流"><a href="#四、服务端限流" class="headerlink" title="四、服务端限流"></a>四、服务端限流</h2><h3 id="4-1-限制某个接口的总并发数-请求数"><a href="#4-1-限制某个接口的总并发数-请求数" class="headerlink" title="4.1 限制某个接口的总并发数/请求数"></a>4.1 限制某个接口的总并发数/请求数</h3><p>若接口可能会遇到瞬时高流量访问情况，可能会因为访问量太大造成崩溃，此时需要限制这个接口的总并发/总请求数。由于粒度较细，可以为每个接口都设置相应的阀值。<br>可以使用Java中的AtomicLong进行限流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴，没有平滑处理</span></span><br><span class="line"><span class="keyword">long</span> limit = <span class="number">200L</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(atomic.incrementAndGet() &gt; 限流数) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拒绝请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.decrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-限流某个接口的时间窗请求数"><a href="#4-2-限流某个接口的时间窗请求数" class="headerlink" title="4.2 限流某个接口的时间窗请求数"></a>4.2 限流某个接口的时间窗请求数</h3><p>即一个时间窗口内的请求数，如想限制某个接口或服务每秒/每分钟/每天的请求数或调用量。一些基础服务会被很多其他系统调用，比如商品详情页服务会调用基础商品服务，但是怕因为更新量比较大将基础服务打挂，这时我们要对秒级/分钟级的调用量进行限速。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/18 22:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowRateLimit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用Guava的Cache来存储计数器，过期时间设置为2秒（保证1秒内的计数器是有的）</span></span><br><span class="line">    <span class="comment">// 获取当前时间戳然后取秒数来作为KEY进行计数统计和限流，这种方式也是简单粗暴</span></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;Long, AtomicLong&gt; counter = CacheBuilder.newBuilder()</span><br><span class="line">        <span class="comment">//设置要统计缓存的命中率</span></span><br><span class="line">        .recordStats()</span><br><span class="line">        <span class="comment">//设置写缓存后2秒钟过期</span></span><br><span class="line">        .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS).build(<span class="keyword">new</span> CacheLoader&lt;Long, AtomicLong&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">load</span><span class="params">(Long seconds)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ExecutionException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 该接口限流1000</span></span><br><span class="line">        <span class="keyword">long</span> limit = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//得到当前秒</span></span><br><span class="line">            <span class="keyword">long</span> currentSeconds = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter.get(currentSeconds).incrementAndGet() &gt; limit)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"限流了:"</span> + currentSeconds);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//业务处理</span></span><br><span class="line">            System.out.println(<span class="string">"处理业务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-平滑限流某个接口的请求数"><a href="#4-3-平滑限流某个接口的请求数" class="headerlink" title="4.3 平滑限流某个接口的请求数"></a>4.3 平滑限流某个接口的请求数</h3><ol>
<li>上述的两种限流方式都不能很好地应对突发请求，即瞬间请求可能都被允许从而导致一些问题。因此在一些场景中需要对突发请求进行整形，整形为平均速率请求处理（比如5r/s，则每隔200毫秒处理一个请求，平滑了速率）。面对这种场景，可以采用令牌桶算法或漏桶算法。</li>
<li>Guava RateLimiter提供了令牌桶算法实现：一种是平滑突发限流(SmoothBursty)，另一种是平滑预热限流(SmoothWarmingUp)</li>
</ol>
<h4 id="4-3-1-常规速率-SmoothBursty（平滑输出）"><a href="#4-3-1-常规速率-SmoothBursty（平滑输出）" class="headerlink" title="4.3.1 常规速率 SmoothBursty（平滑输出）"></a>4.3.1 常规速率 SmoothBursty（平滑输出）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌</span></span><br><span class="line">    RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// acquire()表示消费一个令牌，并且返回获取这个令牌所需要的时间。</span></span><br><span class="line">        <span class="comment">// 如果当前桶中有足够令牌则成功。如果桶中没有令牌则暂停一段时间，直到有令牌。</span></span><br><span class="line">        <span class="comment">// 比如发令牌间隔是200毫秒，则等待200毫秒后再去消费令牌</span></span><br><span class="line">        <span class="comment">// acquire(N)可以获取多个令牌</span></span><br><span class="line">        System.out.println(r.acquire());</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 0.0</span></span><br><span class="line">        <span class="comment">// 0.195734</span></span><br><span class="line">        <span class="comment">// 0.174035</span></span><br><span class="line">        <span class="comment">// 0.17114</span></span><br><span class="line">        <span class="comment">// 0.199599</span></span><br><span class="line">        <span class="comment">// 0.199641</span></span><br><span class="line">        <span class="comment">// 0.196775</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-SmoothBursty-突发流量"><a href="#4-3-2-SmoothBursty-突发流量" class="headerlink" title="4.3.2 SmoothBursty 突发流量"></a>4.3.2 SmoothBursty 突发流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 表示桶的容量为5且每秒新增5个令牌</span></span><br><span class="line">    <span class="comment">// 令牌桶算法允许一定程度的突发，所以可以一次性消费5个令牌</span></span><br><span class="line">    <span class="comment">// 但接下来的limiter.acquire(1)将等待差不多1秒桶中才能有令牌，且接下来的请求也整形为固定速率了。</span></span><br><span class="line">    RateLimiter limiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(limiter.acquire(<span class="number">5</span>));</span><br><span class="line">    System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 突发流量可以是突发的多，也可以是突发的少</span></span><br><span class="line">    <span class="comment">// Thread.sleep(2000);</span></span><br><span class="line">    System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-SmoothWarmingUp-带缓冲的流量输出"><a href="#4-3-3-SmoothWarmingUp-带缓冲的流量输出" class="headerlink" title="4.3.3 SmoothWarmingUp 带缓冲的流量输出"></a>4.3.3 SmoothWarmingUp 带缓冲的流量输出</h4><ol>
<li>由于SmoothBursty允许一定程度的突发，假设突然间来了很大的流量，那么系统很可能扛不住这种突发。因此需要一种平滑速率的限流工具，从而让系统冷启动后慢慢的趋于平均固定速率（即刚开始速率小一些，然后慢慢趋于我们设置的固定速率）。</li>
<li>Guava也提供了SmoothWarmingUp来实现这种场景，其可以认为是漏桶算法，但是在某些特殊场景又不太一样。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 速率是梯形上升速率的，即冷启动时会以一个比较大的速率慢慢到平均速率，然后趋于平均速率（梯形下降到平均速率）</span></span><br><span class="line"><span class="comment">// 可以通过调节warmupPeriod参数实现一开始就是平滑固定速率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个限流器，设置每秒放置的令牌数为2</span></span><br><span class="line">    <span class="comment">// 设置缓冲时间（在从冷启动速率过渡到平均速率的时间间隔）为3秒</span></span><br><span class="line">    <span class="comment">// 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。</span></span><br><span class="line">    <span class="comment">// 达到平滑输出的效果</span></span><br><span class="line">    RateLimiter r = RateLimiter.create(<span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(r.acquire(<span class="number">1</span>));</span><br><span class="line">        System.out.println(r.acquire(<span class="number">1</span>));</span><br><span class="line">        System.out.println(r.acquire(<span class="number">1</span>));</span><br><span class="line">        System.out.println(r.acquire(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-4-Alibaba-Sentinel"><a href="#4-4-Alibaba-Sentinel" class="headerlink" title="4.4 Alibaba Sentinel"></a>4.4 Alibaba Sentinel</h3><ol>
<li>Sentinel 是一个带配置中心的分布式缓存，以 “资源名称” 为统计点，提供了多种方式的限流方案，可以基于 QPS、线程数，甚至系统 load 进行集群规模的限流。</li>
<li>spring cloud中可以使用@SentinelResource注解，来进行限流或是降级的保护。</li>
</ol>
<h2 id="五、分布式限流"><a href="#五、分布式限流" class="headerlink" title="五、分布式限流"></a>五、分布式限流</h2><ol>
<li>分布式限流最关键的是要将限流服务做成原子化，而解决方案可以使使用redis+lua或者nginx+lua技术进行实现，通过这两种技术可以实现的高并发和高性能。</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://dcrunnn.github.io/2020/06/17/高并发处理-限流/" data-id="ckfcddp8c0022b4ubfok6x4hv" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aS27DMAwFwN7/0inQbSL3kYzRRhqvgkQ1NC5Ai5+vr/h6/FzXn5/Xr35drUn+anRhYGB8LONxeSWM1TfPG7reaHK35R0wMDAOYCRBNqFWw+WKmu8NAwMDIz8CJhu6DuUYGBgY7w24vSNjnodiYGBg9JLYPFxWwZMjKQYGxgmMdzUG7vj8B/0NDAyMf8Z4FK9q4ax60GzuCgMDY2tGcjirbnQylpE0G5Z7wMDAOICR3yJPdKthOmkwFMptGBgYGzF6Zf0kvFa/SYY2fnlAGBgY2zFG7l5AHDyy6I2BgYFxJKNXn6+G1Lwx8GIlBgbGAYzqiEMeLntHzDzUYmBgnMBIym1JYS5fU2XnwR0DA+MERnUrSVjsBehmCwEDA2NTRtKGvDtBLaesGBgYRzLy0Yr7hsaqLYflGwMDA2M7Rp5G5qNgk1ZB/pjK/xMMDIyNGEn5LD/e9Q6UebuiGe8xMDA+kDEZ3poE2V7BrjwOgoGBsQWjNx4xaRLk4bvQQsDAwNiUMRluqMbySXsgKrRhYGBszcjTxTuS0rzxuVyDgYGxNaNX0ioXvAYtzEL+jYGBsSnjUbyqQxjVhDZvi754b2BgYGzKeEO0jlue+YBX7/iIgYGxNyMPstURjcnoRnOoAgMDY2vGZNhiTurtc1luw8DAOJjx3iJdb2XUyMTAwMCIQ/CkYVl+ZBgYGAcwJsX6XiOzV/+LZtwwMDC2Y0wSyPvK/c0DIgYGxm6Mb9nJA/FBk6m5AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/高并发/">高并发</a><a href="/tags/分布式/">分布式</a><a href="/tags/限流/">限流</a></div><div class="post-nav"><a class="next" href="/2020/04/30/Go学习资料整合/">Go学习资料整合</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://dcrunnn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能与机器学习/">人工智能与机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情/">心情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/">技术整理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术整理/Windows/">Windows</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/编程规范/">编程规范</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发/">高并发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/Enum/" style="font-size: 15px;">Enum</a> <a href="/tags/知识/" style="font-size: 15px;">知识</a> <a href="/tags/参数传递/" style="font-size: 15px;">参数传递</a> <a href="/tags/学习记录/" style="font-size: 15px;">学习记录</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/数据恢复/" style="font-size: 15px;">数据恢复</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/前后端分离/" style="font-size: 15px;">前后端分离</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/阿里云镜像/" style="font-size: 15px;">阿里云镜像</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/人工智能与机器学习/" style="font-size: 15px;">人工智能与机器学习</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/分布式SQL引擎/" style="font-size: 15px;">分布式SQL引擎</a> <a href="/tags/分布式ETL工具/" style="font-size: 15px;">分布式ETL工具</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/分布式文件系统/" style="font-size: 15px;">分布式文件系统</a> <a href="/tags/分布式数据采集工具/" style="font-size: 15px;">分布式数据采集工具</a> <a href="/tags/分布式消息队列/" style="font-size: 15px;">分布式消息队列</a> <a href="/tags/分布式计算框架/" style="font-size: 15px;">分布式计算框架</a> <a href="/tags/分布式资源管理框架/" style="font-size: 15px;">分布式资源管理框架</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/滑动窗口/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/矩阵/" style="font-size: 15px;">矩阵</a> <a href="/tags/歌曲/" style="font-size: 15px;">歌曲</a> <a href="/tags/高并发/" style="font-size: 15px;">高并发</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a> <a href="/tags/编程规范/" style="font-size: 15px;">编程规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/高并发处理-限流/">高并发处理 | 限流</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/Go学习资料整合/">Go学习资料整合</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/nil理解及empty的使用场景/">nil理解及empty的使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/Go-Concurrency-Learning/">Go Concurrency Learning</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/JavaDaily/">JavaDaily</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/《Java8实战》-Chapter3-Lambda表达式/">《Java8实战》| Chapter3 Lambda表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/《Java8实战》-Chapter2 通过行为参数化传递代码/">《Java8实战》 | Chapter2 通过行为参数化传递代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/记一次右键菜单失效修复注册表的过程/">记一次右键菜单失效修复注册表的过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/《Java8实战》-Chapter1 为什么要关心Java8/">《Java8实战》 | Chapter1 为什么要关心Java8</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/12/人工智能与机器学习概述/">人工智能与机器学习概述</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://www.github.com/DCRUNNN" title="Github" target="_blank">Github</a><ul></ul><a href="https://instagram.com/youdontknowdc" title="Instagram" target="_blank">Instagram</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Blog of DC.</a><!--|  Powered by--><!--a(rel='nofollow', target='_blank', href='https://hexo.io')  Hexo.--><!--a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!--|  by--><!--a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>